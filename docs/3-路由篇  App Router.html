
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>3-路由篇  App Router</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>路由（Router）是 Next.js 应用的重要组成部分。在 Next.js 中，路由决定了一个页面如何渲染或者一个请求该如何返回。</p>
<p>Next.js 有两套路由解决方案，之前的方案称之为“Pages Router”，目前的方案称之为“App Router”，两套方案目前是兼容的，都可以在 Next.js 中使用。</p>
<p>从 v13.4 起，App Router 已成为默认的路由方案，新的 Next.js 项目建议使用 App Router。</p>
<p>本篇我们会学习 App Router 下路由的定义方式和常见的文件约定。</p>
<h2>1. 文件系统（file-system）</h2>
<p>Next.js 的路由基于的是文件系统，也就是说，一个文件就可以是一个路由。举个例子，你在 <code>pages</code> 目录下创建一个 <code>index.js</code> 文件，它会直接映射到 <code>/</code> 路由地址：</p>
<pre><code class="language-javascript">// pages/index.js
import React from &#39;react&#39;
export default () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;
</code></pre>
<p>在 <code>pages</code> 目录下创建一个 <code>about.js</code> 文件，它会直接映射到 <code>/about</code> 路由地址：</p>
<pre><code class="language-javascript">// pages/about.js
import React from &#39;react&#39;
export default () =&gt; &lt;h1&gt;About us&lt;/h1&gt;
</code></pre>
<h2>2. 从 Pages Router 到 App Router</h2>
<p>现在你打开使用 <code>create-next-app</code> 创建的项目，你会发现默认并没有 <code>pages</code> 这个目录。查看 <code>packages.json</code>中的 Next.js 版本，如果版本号大于 <code>13.4</code>，那就对了！</p>
<p>Next.js 从 v13 起就使用了新的路由模式 —— App Router。之前的路由模式我们称之为“Pages Router”，为保持渐进式更新，依然存在。从 v13.4 起，App Router 正式进入稳定化阶段，App Router 功能更强、性能更好、代码组织更灵活，以后就让我们使用新的路由模式吧！</p>
<p>可是这俩到底有啥区别呢？Next.js 又为什么升级到 App Router 呢？知其然知其所以然，让我们简单追溯一下。以前我们声明一个路由，只用在 <code>pages</code> 目录下创建一个文件就可以了，以前的目录结构类似于：</p>
<pre><code class="language-javascript">└── pages
    ├── index.js
    ├── about.js
    └── more.js
</code></pre>
<p>这种方式有一个弊端，那就是 <code>pages</code> 目录的所有 js 文件都会被当成路由文件，这就导致比如组件不能写在 <code>pages</code> 目录下，这就不符合开发者的使用习惯。（当然 Pages Router 还有很多其他的问题，只不过目前我们介绍的内容还太少，为了不增加大家的理解成本，就不多说了）</p>
<p>升级为新的 App Router 后，现在的目录结构类似于：</p>
<pre><code class="language-javascript">src/
└── app
    ├── page.js 
    ├── layout.js
    ├── template.js
    ├── loading.js
    ├── error.js
    └── not-found.js
    ├── about
    │   └── page.js
    └── more
        └── page.js
</code></pre>
<p>使用新的模式后，你会发现 <code>app</code> 下多了很多文件。这些文件的名字并不是我乱起的，而是 Next.js 约定的一些特殊文件。从这些文件的名称中你也可以了解文件实现的功能，比如布局（layout.js）、模板（template.js）、加载状态（loading.js）、错误处理（error.js）、404（not-found.js）等。</p>
<p>简单的来说，App Router 制定了更加完善的规范，使代码更好被组织和管理。至于这些文件具体的功能和介绍，不要着急，本篇我们会慢慢展开。</p>
<h2>3. 使用 Pages Router</h2>
<p>当然你也可以继续使用 Pages Router，如果你想使用 Pages Router，只需要在 <code>src</code> 目录下创建一个 <code>pages</code> 文件夹或者在根目录下创建一个 <code>pages</code>文件夹。其中的 JS 文件会被视为 Pages Router 进行处理。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e3628b5a76b4bdc87b423b377f80946~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=444&s=212184&e=png&b=141414" alt="image.png"></p>
<p>但是要注意，虽然两者可以共存，但 App Router 的优先级要高于 Pages Router。而且如果两者解析为同一个 URL，会导致构建错误。</p>
<p>注意：你在 Next.js 官方文档进行搜索的时候，左上角会有 App 和 Pages 选项，这对应的就是 App Router 和 Pages Router：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab940655f6c14e428a72c91b1f727681~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1382&h=586&s=71771&e=png&b=040404" alt="image.png"></p>
<p>因为两种路由模式的使用方式有很大不同，所以搜索的时候注意选择正确的的路由模式。</p>
<h2>4. 使用 App Router</h2>
<h3>4.1. 定义路由（Routes）</h3>
<p>现在让我们开始正式的学习 App Router 吧。</p>
<p>首先是定义路由，文件夹被用来定义路由。每个文件夹都代表一个对应到 URL 片段的路由片段。创建嵌套的路由，只需要创建嵌套的文件夹。举个例子，下图的 <code>app/dashboard/settings</code>目录对应的路由地址就是 <code>/dashboard/settings</code>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c35a76b0027c4e9fb5bc0d5807f479f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=594&s=339521&e=png&b=141414" alt="image.png"></p>
<h3>4.2. 定义页面（Pages）</h3>
<p>那如何保证这个路由可以被访问呢？你需要创建一个特殊的名为 <code>page.js</code> 的文件。至于为什么叫 <code>page.js</code>呢？除了 <code>page</code> 有“页面”这个含义之外，你可以理解为这是一种约定或者规范。（如果你是 Next.js 的开发者，你也可以约定为 <code>index.js</code>甚至 <code>yayu.js</code>！）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40820ff4957244899288d7534bd4c525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=687&s=314397&e=png&b=171717" alt="image.png"></p>
<p>在上图这个例子中：</p>
<ul>
<li><code>app/page.js</code> 对应路由 <code>/</code></li>
<li><code>app/dashboard/page.js</code> 对应路由 <code>/dashboard</code></li>
<li><code>app/dashboard/settings/page.js</code> 对应路由<code>/dashboard/settings</code></li>
<li><code>analytics</code> 目录下因为没有 <code>page.js</code> 文件，所以没有对应的路由。这个文件可以被用于存放组件、样式表、图片或者其他文件。</li>
</ul>
<p><strong>当然不止 <code>.js</code>文件，Next.js 默认是支持 React、TypeScript 的，所以 <code>.js</code>、<code>.jsx</code>、<code>.tsx</code> 都是可以的。</strong></p>
<p>那 <code>page.js</code> 的代码该如何写呢？最常见的是展示 UI，比如：</p>
<pre><code class="language-javascript">// app/page.js
export default function Page() {
  return &lt;h1&gt;Hello, Next.js!&lt;/h1&gt;
}
</code></pre>
<p>访问 <code>http://localhost:3000/</code>，效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d38b112da542488c81d5412fc407ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=556&h=200&s=19870&e=png&b=000000" alt="image.png"></p>
<p>线上查看代码和效果：<a href="https://codesandbox.io/p/devbox/objective-ellis-ywn8jd?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt475kks00073b6iw2cbcpjg%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt475kkr00023b6ihi25h458%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt475kkr00043b6i9lkjph4n%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt475kks00063b6i9l5o6xnw%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt475kkr00023b6ihi25h458%2522%253A%257B%2522id%2522%253A%2522clt475kkr00023b6ihi25h458%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522clt475kks00063b6i9l5o6xnw%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt475kkr00053b6i8y93zpk4%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clt475kks00063b6i9l5o6xnw%2522%252C%2522activeTabId%2522%253A%2522clt475kkr00053b6i8y93zpk4%2522%257D%252C%2522clt475kkr00043b6i9lkjph4n%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt475kkr00033b6i40hrddok%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt475kkr00043b6i9lkjph4n%2522%252C%2522activeTabId%2522%253A%2522clt475kkr00033b6i40hrddok%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D">CodeSandbox Pages</a></p>
<h3>4.3. 定义布局（Layouts）</h3>
<p>布局是指多个页面共享的 UI。在导航的时候，布局会保留状态、保持可交互性并且不会重新渲染，比如用来实现后台管理系统的侧边导航栏。</p>
<p>定义一个布局，你需要新建一个名为 <code>layout.js</code>的文件，该文件默认导出一个 React 组件，该组件应接收一个 <code>children</code> prop，<code>chidren</code> 表示子布局（如果有的话）或者子页面。</p>
<p>举个例子，我们新建目录和文件如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a7872449f6e4c6fb1808f518db7783f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=606&s=295670&e=png&b=151515" alt="image.png"></p>
<p>相关代码如下：</p>
<pre><code class="language-javascript">// app/dashboard/layout.js
export default function DashboardLayout({
  children,
}) {
  return (
    &lt;section&gt;
      &lt;nav&gt;nav&lt;/nav&gt;
      {children}
    &lt;/section&gt;
  )
}
</code></pre>
<pre><code class="language-javascript">// app/dashboard/page.js
export default function Page() {
  return &lt;h1&gt;Hello, Dashboard!&lt;/h1&gt;
}
</code></pre>
<p>当访问 <code>/dashboard</code>的时候，效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43c72c2017354f1e9c292c2bbb9aaa40~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=268&s=27102&e=png&b=000000" alt="image.png"></p>
<p>其中，<code>nav</code> 来自于 <code>app/dashboard/layout.js</code>，<code>Hello, Dashboard!</code> 来自于 <code>app/dashboard/page.js</code></p>
<p><strong>你可以发现：同一文件夹下如果有 layout.js 和 page.js，page 会作为 children 参数传入 layout。换句话说，layout 会包裹同层级的 page。</strong></p>
<p><code>app/dashboard/settings/page.js</code> 代码如下：</p>
<pre><code class="language-javascript">// app/dashboard/settings/page.js
export default function Page() {
  return &lt;h1&gt;Hello, Settings!&lt;/h1&gt;
}
</code></pre>
<p>当访问 <code>/dashboard/settings</code>的时候，效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53456de28a684fe3902eb2ce5f4c07a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=808&h=266&s=29753&e=png&b=000000" alt="image.png"></p>
<p>其中，<code>nav</code> 来自于 <code>app/dashboard/layout.js</code>，<code>Hello, Settings!</code> 来自于 <code>app/dashboard/settings/page.js</code></p>
<p><strong>你可以发现：布局是支持嵌套的</strong>，<code>app/dashboard/settings/page.js</code> 会使用 <code>app/layout.js</code> 和 <code>app/dashboard/layout.js</code> 两个布局中的内容，不过因为我们没有在 <code>app/layout.js</code> 写入可以展示的内容，所以图中没有体现出来。</p>
<p>线上查看代码和效果：<a href="https://codesandbox.io/p/devbox/layouts-v3csx2?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt489j2g00073b6h88j62aog%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt489j2g00023b6he9lxbh9s%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt489j2g00043b6h2v7dpi6i%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt489j2g00063b6hmqcdputt%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt489j2g00023b6he9lxbh9s%2522%253A%257B%2522id%2522%253A%2522clt489j2g00023b6he9lxbh9s%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522clt489j2g00063b6hmqcdputt%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt489j2g00053b6hi3oec3fe%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%252Fsettings%2522%257D%255D%252C%2522id%2522%253A%2522clt489j2g00063b6hmqcdputt%2522%252C%2522activeTabId%2522%253A%2522clt489j2g00053b6hi3oec3fe%2522%257D%252C%2522clt489j2g00043b6h2v7dpi6i%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt489j2g00033b6h5p3d7t5v%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt489j2g00043b6h2v7dpi6i%2522%252C%2522activeTabId%2522%253A%2522clt489j2g00033b6h5p3d7t5v%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D">CodeSandbox Layouts</a></p>
<h4>根布局（Root Layout）</h4>
<p>布局支持嵌套，最顶层的布局我们称之为根布局（Root Layout），也就是 <code>app/layout.js</code>。它会应用于所有的路由。除此之外，这个布局还有点特殊。</p>
<p>使用 <code>create-next-app</code> 默认创建的 <code>layout.js</code> 代码如下：</p>
<pre><code class="language-javascript">// app/layout.js
import &#39;./globals.css&#39;
import { Inter } from &#39;next/font/google&#39;

const inter = Inter({ subsets: [&#39;latin&#39;] })

export const metadata = {
  title: &#39;Create Next App&#39;,
  description: &#39;Generated by create next app&#39;,
}

export default function RootLayout({ children }) {
  return (
    &lt;html lang=&quot;en&quot;&gt;
      &lt;body className={inter.className}&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  )
}
</code></pre>
<p>其中：</p>
<ol>
<li><code>app</code> 目录必须包含根布局，也就是 <code>app/layout.js</code> 这个文件是必需的。</li>
<li>根布局必须包含 <code>html</code> 和 <code>body</code>标签，其他布局不能包含这些标签。如果你要更改这些标签，不推荐直接修改，参考<a href="https://juejin.cn/book/7307859898316881957/section/7309079119902277669">《Metadata 篇》</a>。</li>
<li>你可以使用<a href="https://juejin.cn/book/7307859898316881957/section/7308693561648611379#heading-5">路由组</a>创建多个根布局。</li>
<li>默认根布局是<a href="https://juejin.cn/book/7307859898316881957/section/7309076661532622885">服务端组件</a>，且不能设置为客户端组件。</li>
</ol>
<h3>4.4. 定义模板（Templates）</h3>
<p>模板类似于布局，它也会传入每个子布局或者页面。但不会像布局那样维持状态。</p>
<p>模板在路由切换时会为每一个 children  创建一个实例。这就意味着当用户在共享一个模板的路由间跳转的时候，将会重新挂载组件实例，重新创建 DOM 元素，不保留状态。这听起来有点抽象，没有关系，我们先看看模板的写法，再写个 demo 你就明白了。</p>
<p>定义一个模板，你需要新建一个名为 <code>template.js</code> 的文件，该文件默认导出一个 React 组件，该组件接收一个 <code>children</code> prop。我们写个示例代码。</p>
<p>在 <code>app</code>目录下新建一个 <code>template.js</code>文件：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e19139c038fe4c528f89874541928670~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=444&s=216678&e=png&b=151515" alt="image.png"></p>
<p><code>template.js</code> 代码如下：</p>
<pre><code class="language-javascript">// app/template.js
export default function Template({ children }) {
  return &lt;div&gt;{children}&lt;/div&gt;
}
</code></pre>
<p>你会发现，这用法跟布局一模一样。它们最大的区别就是状态的保持。如果同一目录下既有 <code>template.js</code> 也有 <code>layout.js</code>，最后的输出效果如下：</p>
<pre><code class="language-javascript">&lt;Layout&gt;
  {/* 模板需要给一个唯一的 key */}
  &lt;Template key={routeParam}&gt;{children}&lt;/Template&gt;
&lt;/Layout&gt;
</code></pre>
<p>也就是说 <code>layout</code> 会包裹 <code>template</code>，<code>template</code> 又会包裹 <code>page</code>。</p>
<p>某些情况下，模板会比布局更适合：</p>
<ul>
<li><p>依赖于 useEffect 和 useState 的功能，比如记录页面访问数（维持状态就不会在路由切换时记录访问数了）、用户反馈表单（每次重新填写）等</p>
</li>
<li><p>更改框架的默认行为，举个例子，布局内的 Suspense 只会在布局加载的时候展示一次 fallback UI，当切换页面的时候不会展示。但是使用模板，fallback 会在每次路由切换的时候展示</p>
</li>
</ul>
<p>注：关于模板的适用场景，可以参考<a href="https://juejin.cn/post/7343569488744300553">《Next.js v14 的模板（template.js）到底有啥用？》</a>，对这两种情况都做了举例说明</p>
<h4>布局 VS 模板</h4>
<p>为了帮助大家更好的理解布局和模板，我们写一个 demo，展示下两者的特性。</p>
<p>项目目录如下：</p>
<pre><code class="language-javascript">app
└─ dashboard
   ├─ layout.js
   ├─ page.js
   ├─ template.js
   ├─ about
   │  └─ page.js
   └─ settings
      └─ page.js
</code></pre>
<p>其中 <code>dashboard/layout.js</code> 代码如下：</p>
<pre><code class="language-javascript">&#39;use client&#39;

import { useState } from &#39;react&#39;
import Link from &#39;next/link&#39;

export default function Layout({ children }) {
  const [count, setCount] = useState(0)
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;Link href=&quot;/dashboard/about&quot;&gt;About&lt;/Link&gt;
        &lt;br/&gt;
        &lt;Link href=&quot;/dashboard/settings&quot;&gt;Settings&lt;/Link&gt;
      &lt;/div&gt;
      &lt;h1&gt;Layout {count}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
      {children}
    &lt;/&gt;
  )
}
</code></pre>
<p><code>dashboard/template.js</code> 代码如下：</p>
<pre><code class="language-javascript">&#39;use client&#39;

import { useState } from &#39;react&#39;

export default function Template({ children }) {
  const [count, setCount] = useState(0)
  return (
    &lt;&gt;
      &lt;h1&gt;Template {count}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
      {children}
    &lt;/&gt;
  )
}
</code></pre>
<p><code>dashboard/page.js</code>代码如下：</p>
<pre><code class="language-javascript">export default function Page() {
  return &lt;h1&gt;Hello, Dashboard!&lt;/h1&gt;
}
</code></pre>
<p><code>dashboard/about/page.js</code>代码如下：</p>
<pre><code class="language-javascript">export default function Page() {
  return &lt;h1&gt;Hello, About!&lt;/h1&gt;
}
</code></pre>
<p><code>dashboard/settings/page.js</code>代码如下：</p>
<pre><code class="language-javascript">export default function Page() {
  return &lt;h1&gt;Hello, Settings!&lt;/h1&gt;
}
</code></pre>
<p>最终展示效果如下（为了方便区分，做了部分样式处理）：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d33ef3073ed46ce9f234880630246dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2558&h=1624&s=480097&e=png&b=000000" alt="image.png"></p>
<p>现在点击两个 <code>Increment</code> 按钮，会开始计数。随便点击下数字，然后再点击 <code>About</code>或者 <code>Settings</code>切换路由，你会发现，Layout 后的数字没有发生变化，Template 后的数字重置为 0。这就是所谓的状态保持。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461a47c030d64fc7890e35de58feb950~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450&h=342&s=33835&e=gif&f=54&b=010101" alt="10.gif"></p>
<p>注：当然如果刷新页面，Layout 和 Template 后的数字肯定都重置为 0。</p>
<p>线上查看代码和效果：<a href="https://codesandbox.io/p/devbox/templates-h25kzz?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt48u2gb00073b6hi8zrj7z5%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt48u2gb00023b6h6qaf1m82%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt48u2gb00043b6hvw4el4sp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt48u2gb00063b6ht7hvjihq%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt48u2gb00023b6h6qaf1m82%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt48u2ga00013b6hrwr6p06f%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252FREADME.md%2522%257D%255D%252C%2522id%2522%253A%2522clt48u2gb00023b6h6qaf1m82%2522%252C%2522activeTabId%2522%253A%2522clt48u2ga00013b6hrwr6p06f%2522%257D%252C%2522clt48u2gb00063b6ht7hvjihq%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt48u2gb00053b6ho6d4dyg7%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%2522%257D%255D%252C%2522id%2522%253A%2522clt48u2gb00063b6ht7hvjihq%2522%252C%2522activeTabId%2522%253A%2522clt48u2gb00053b6ho6d4dyg7%2522%257D%252C%2522clt48u2gb00043b6hvw4el4sp%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt48u2gb00033b6hgzgomtf5%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt48u2gb00043b6hvw4el4sp%2522%252C%2522activeTabId%2522%253A%2522clt48u2gb00033b6hgzgomtf5%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D">CodeSandbox Templates VS Layouts</a></p>
<h3>4.5. 定义加载界面（Loading UI）</h3>
<p>现在我们已经了解了 <code>page.js</code>、<code>layout.js</code>、<code>template.js</code>的功能，然而特殊文件还不止这些。App Router 提供了用于展示加载界面的 <code>loading.js</code>。</p>
<p>这个功能的实现借助了 React 的<code>Suspense</code> API。关于 Suspense 的用法，可以查看 <a href="https://juejin.cn/post/7163934860694781989">《React 之 Suspense》</a>。它实现的效果就是当发生路由变化的时候，立刻展示 fallback UI，等加载完成后，展示数据。</p>
<pre><code class="language-jsx">// 在 ProfilePage 组件处于加载阶段时显示 Spinner
&lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
  &lt;ProfilePage /&gt;
&lt;/Suspense&gt;
</code></pre>
<p>初次接触 Suspense 这个概念的时候，往往会有一个疑惑，那就是——“在哪里控制关闭 fallback UI 的呢？”</p>
<p>哪怕在 React 官网中，对背后的实现逻辑并无过多提及。但其实实现的逻辑很简单，简单的来说，ProfilePage 会 throw 一个数据加载的 promise，Suspense 会捕获这个 promise，追加一个 then 函数，then 函数中实现替换 fallback UI 。当数据加载完毕，promise 进入 resolve 状态，then 函数执行，于是更新替换 fallback UI。</p>
<p>了解了原理，那我们来看看如何写这个 <code>loading.js</code>吧。<code>dashboard</code> 目录下我们新建一个 <code>loading.js</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a410face8c0443bda0bba48a3fa4a602~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=606&s=292947&e=png&b=151515" alt="image.png"></p>
<p><code>loading.js</code>的代码如下：</p>
<pre><code class="language-javascript">// app/dashboard/loading.js
export default function DashboardLoading() {
  return &lt;&gt;Loading dashboard...&lt;/&gt;
}
</code></pre>
<p>同级的 <code>page.js</code> 代码如下：</p>
<pre><code class="language-javascript">// app/dashboard/page.js
async function getData() {
  await new Promise((resolve) =&gt; setTimeout(resolve, 3000))
  return {
    message: &#39;Hello, Dashboard!&#39;,
  }
}
export default async function DashboardPage(props) {
  const { message } = await getData()
  return &lt;h1&gt;{message}&lt;/h1&gt;
}
</code></pre>
<p>不再需要其他的代码，loading 的效果就实现了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd31cc361fb418f9657597e6916cc59~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450&h=342&s=7964&e=gif&f=9&b=000000" alt="11.gif"></p>
<p>线上查看代码和效果：<a href="https://codesandbox.io/p/devbox/loading-yw7zlg?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt4b2khv00073b6hu9pjxkod%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt4b2khv00023b6hl69ez1j6%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt4b2khv00043b6hupnzd9jd%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt4b2khv00063b6his95k772%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt4b2khv00023b6hl69ez1j6%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00013b6hs9i6fr2l%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252FREADME.md%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00023b6hl69ez1j6%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00013b6hs9i6fr2l%2522%257D%252C%2522clt4b2khv00063b6his95k772%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00053b6hmql3m7p5%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00063b6his95k772%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00053b6hmql3m7p5%2522%257D%252C%2522clt4b2khv00043b6hupnzd9jd%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00033b6h55d7v2oi%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00043b6hupnzd9jd%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00033b6h55d7v2oi%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D">CodeSandbox Loading</a></p>
<p>就是这么简单。其关键在于 <code>page.js</code>导出了一个 async 函数。</p>
<p><code>loading.js</code> 的实现原理是将 <code>page.js</code>和下面的 children 用 <code>&lt;Suspense&gt;</code> 包裹。因为<code>page.js</code>导出一个 async 函数，Suspense 得以捕获数据加载的 promise，借此实现了 loading 组件的关闭。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/804284470c16423eb3d3d2d4510996ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=766&s=442672&e=png&b=191919" alt="image.png"></p>
<p>当然实现 loading 效果，不一定非导出一个 async 函数。也可以借助 React 的 <code>use</code> 函数。现在我们在 <code>dashboard</code>下新建一个 <code>about</code>目录，在其中新建 <code>page.js</code>文件。</p>
<p><code>/dashboard/about/page.js</code> 代码如下：</p>
<pre><code class="language-javascript">// /dashboard/about/page.js
import { use } from &#39;react&#39;

async function getData() {
  await new Promise((resolve) =&gt; setTimeout(resolve, 5000))
  return {
    message: &#39;Hello, About!&#39;,
  }
}

export default function Page() {
  const {message} = use(getData())
  return &lt;h1&gt;{message}&lt;/h1&gt;
}
</code></pre>
<p>同样实现了 loading  效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa3f3e67b3e348348c03a6492e4581f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450&h=342&s=6554&e=gif&f=6&b=000000" alt="12.gif"></p>
<p>线上查看代码和效果：<a href="https://codesandbox.io/p/devbox/loading-yw7zlg?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt4b2khv00073b6hu9pjxkod%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt4b2khv00023b6hl69ez1j6%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt4b2khv00043b6hupnzd9jd%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt4b2khv00063b6his95k772%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt4b2khv00023b6hl69ez1j6%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00013b6hs9i6fr2l%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252FREADME.md%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00023b6hl69ez1j6%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00013b6hs9i6fr2l%2522%257D%252C%2522clt4b2khv00063b6his95k772%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00053b6hmql3m7p5%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%252Fabout%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00063b6his95k772%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00053b6hmql3m7p5%2522%257D%252C%2522clt4b2khv00043b6hupnzd9jd%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00033b6h55d7v2oi%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00043b6hupnzd9jd%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00033b6h55d7v2oi%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D">CodeSandbox Loading</a></p>
<p>如果你想针对 <code>/dashboard/about</code> 单独实现一个 loading 效果，那就在 <code>about</code> 目录下再写一个 <code>loading.js</code> 即可。</p>
<p>如果同一文件夹既有 <code>layout.js</code> 又有 <code>template.js</code> 又有 <code>loading.js</code> ，那它们的层级关系是怎样呢？</p>
<p>对于这些特殊文件的层级问题，直接一张图搞定：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0551d59d32b486e8f869e0e6ca8f157~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=641&s=327102&e=png&b=1c1c1c" alt="image.png"></p>
<h3>4.6. 定义错误处理（Error Handling）</h3>
<p>再讲讲特殊文件 <code>error.js</code>。顾名思义，用来创建发生错误时的展示 UI。</p>
<p>其实现借助了 React 的 <a href="https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary">Error Boundary</a> 功能。简单来说，就是给 page.js 和 children 包了一层 <code>ErrorBoundary</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2005b09883440cdab2d9a2be0217883~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=901&s=497446&e=png&b=1a1a1a" alt="image.png"></p>
<p>我们写一个 demo 演示一下 <code>error.js</code> 的效果。<code>dashboard</code> 目录下新建一个 <code>error.js</code>，目录效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b16665406e384c35870c4aa68ea9875a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=606&s=293046&e=png&b=151515" alt="image.png"></p>
<p><code>dashboard/error.js</code>代码如下：</p>
<pre><code class="language-javascript">&#39;use client&#39; // 错误组件必须是客户端组件
// dashboard/error.js
import { useEffect } from &#39;react&#39;
 
export default function Error({ error, reset }) {
  useEffect(() =&gt; {
    console.error(error)
  }, [error])
 
  return (
    &lt;div&gt;
      &lt;h2&gt;Something went wrong!&lt;/h2&gt;
      &lt;button
        onClick={
          // 尝试恢复
          () =&gt; reset()
        }
      &gt;
        Try again
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>为触发 Error 错误，同级 <code>page.js</code> 的代码如下：</p>
<pre><code class="language-javascript">&quot;use client&quot;;
// dashboard/page.js
import React from &quot;react&quot;;

export default function Page() {
  const [error, setError] = React.useState(false);

  const handleGetError = () =&gt; {
    setError(true);
  };

  return (
    &lt;&gt;{error ? Error() : &lt;button onClick={handleGetError}&gt;Get Error&lt;/button&gt;}&lt;/&gt;
  );
}
</code></pre>
<p>效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e09190375f63426fbe4ac89c5f8e246f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450&h=342&s=15591&e=gif&f=28&b=000000" alt="13.gif"></p>
<p>有时错误是暂时的，只需要重试就可以解决问题。所以 Next.js 会在 <code>error.js</code> 导出的组件中，传入 <code>reset</code> 函数，帮助尝试从错误中恢复。该函数会触发重新渲染错误边界里的内容。如果成功，会替换展示重新渲染的内容。</p>
<p>线上查看代码和效果：<a href="https://codesandbox.io/p/devbox/error-l6gr2j?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt4bdci200073b6h91twyt7o%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt4bdci200023b6h529g4j8y%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt4bdci200043b6hd7knjpp1%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt4bdci200063b6h8vy2xj52%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt4bdci200023b6h529g4j8y%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4bdci100013b6h9h1wm21z%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252FREADME.md%2522%257D%255D%252C%2522id%2522%253A%2522clt4bdci200023b6h529g4j8y%2522%252C%2522activeTabId%2522%253A%2522clt4bdci100013b6h9h1wm21z%2522%257D%252C%2522clt4bdci200063b6h8vy2xj52%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4bdci200053b6hxtxruqpi%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%2522%257D%255D%252C%2522id%2522%253A%2522clt4bdci200063b6h8vy2xj52%2522%252C%2522activeTabId%2522%253A%2522clt4bdci200053b6hxtxruqpi%2522%257D%252C%2522clt4bdci200043b6hd7knjpp1%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4bdci200033b6hwspjksxq%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt4bdci200043b6hd7knjpp1%2522%252C%2522activeTabId%2522%253A%2522clt4bdci200033b6hwspjksxq%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D">CodeSandbox Error</a></p>
<p>还记得上节讲过的层级问题吗？让我们回顾一下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeb2e4b635f0473785c0ba9d79df01b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=641&s=327102&e=png&b=1c1c1c" alt="image.png"></p>
<p>从这张图里你会发现一个问题：因为 <code>Layout</code> 和 <code>Template</code> 在 <code>ErrorBoundary</code> 外面，这说明错误边界不能捕获同级的 <code>layout.js</code> 或者 <code>template.js</code> 中的错误。如果你想捕获特定布局或者模板中的错误，那就需要在父级的 <code>error.js</code> 里进行捕获。</p>
<p>那问题来了，如果已经到了顶层，就比如根布局中的错误如何捕获呢？为了解决这个问题，Next.js 提供了 <code>global-error.js</code>文件，使用它时，需要将其放在 <code>app</code> 目录下。</p>
<p><code>global-error.js</code>会包裹整个应用，而且当它触发的时候，它会替换掉根布局的内容。所以，<code>global-error.js</code> 中也要定义 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 标签。</p>
<p><code>global-error.js</code>示例代码如下：</p>
<pre><code class="language-javascript">&#39;use client&#39;
// app/global-error.js
export default function GlobalError({ error, reset }) {
  return (
    &lt;html&gt;
      &lt;body&gt;
        &lt;h2&gt;Something went wrong!&lt;/h2&gt;
        &lt;button onClick={() =&gt; reset()}&gt;Try again&lt;/button&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
</code></pre>
<p>注：<code>global-error.js</code> 用来处理根布局和根模板中的错误，<code>app/error.js</code> 建议还是要写的</p>
<h3>4.7. 定义 404 页面</h3>
<p>最后再讲一个特殊文件 —— <code>not-found.js</code>。顾名思义，当该路由不存在的时候展示的内容。</p>
<p>Next.js 项目默认的 not-found 效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92bd888fdae94703885dcec24825c2d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=872&h=340&s=18455&e=png&b=000000" alt="image.png"></p>
<p>如果你要替换这个效果，只需要在 <code>app</code> 目录下新建一个 <code>not-found.js</code>，代码示例如下：</p>
<pre><code class="language-javascript">import Link from &#39;next/link&#39;
 
export default function NotFound() {
  return (
    &lt;div&gt;
      &lt;h2&gt;Not Found&lt;/h2&gt;
      &lt;p&gt;Could not find requested resource&lt;/p&gt;
      &lt;Link href=&quot;/&quot;&gt;Return Home&lt;/Link&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>not-found 的效果就会更改为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aff4d53c41c94d55b597f8d924f13187~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=326&s=37554&e=png&b=000000" alt="image.png"></p>
<p>关于 <code>app/not-found.js</code> 一定要说明一点的是，它只能由两种情况触发：</p>
<ol>
<li>当组件抛出了 notFound 函数的时候</li>
<li>当路由地址不匹配的时候</li>
</ol>
<p>所以 <code>app/not-found.js</code> 可以修改默认 404 页面的样式。但是，如果 <code>not-found.js</code>放到了任何子文件夹下，它只能由 <code>notFound</code>函数手动触发。比如这样：</p>
<pre><code class="language-javascript">// /dashboard/blog/page.js
import { notFound } from &#39;next/navigation&#39;

export default function Page() {
  notFound()
  return &lt;&gt;&lt;/&gt;
}
</code></pre>
<p>执行 notFound 函数时，会由最近的 not-found.js 来处理。但如果直接访问不存在的路由，则都是由 <code>app/not-found.js</code> 来处理。</p>
<p>对应到实际开发，当我们请求一个用户的数据时或是请求一篇文章的数据时，如果该数据不存在，就可以直接丢出 <code>notFound</code> 函数，渲染自定义的 <code>not-found.js</code> 界面。示例代码如下：</p>
<pre><code class="language-javascript">// app/dashboard/blog/[id]/page.js
import { notFound } from &#39;next/navigation&#39;
 
async function fetchUser(id) {
  const res = await fetch(&#39;https://...&#39;)
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({ params }) {
  const user = await fetchUser(params.id)
 
  if (!user) {
    notFound()
  }
 
  // ...
}
</code></pre>
<p>注：后面我们还会讲到“路由组”这个概念，当 <code>app/not-found.js</code> 和路由组一起使用的时候，可能会出现问题。具体参考 <a href="https://juejin.cn/post/7351321244125265930">《Next.js v14 如何为多个根布局自定义不同的 404 页面？竟然还有些麻烦！欢迎探讨》</a></p>
<h2>小结</h2>
<p>恭喜你，完成了本节内容的学习！</p>
<p>这一节我们重点讲解了 Next.js 基于文件系统的路由解决方案 App Router，介绍了用于定义页面的<code>page.js</code>、定义布局的<code>layout.js</code>、定义模板的<code>template.js</code>、定义加载界面的<code>loading.js</code>、定义错误处理的<code>error.js</code>、定义 404 页面的<code>not-found.js</code>。现在你再看 App Router 的这个目录结构：</p>
<pre><code class="language-javascript">src/
└── app
    ├── page.js 
    ├── layout.js
    ├── template.js
    ├── loading.js
    ├── error.js
    └── not-found.js
    ├── about
    │   └── page.js
    └── more
        └── page.js
</code></pre>
<blockquote>
<p>简单的来说，App Router 制定了更加完善的规范，使代码更好被组织和管理。</p>
</blockquote>
<p>对此是不是有了更加深刻的理解呢？然而这还只有 Next.js 强大的路由功能的一小部分。下篇让我们继续学习。</p>
<h2>参考链接</h2>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Routers">Routers - MDN Web Docs Glossary: Definitions of Web-related terms | MDN</a></li>
<li><a href="https://nextjs.org/docs/app/building-your-application/routing">Building Your Application: Routing</a></li>
<li><a href="https://nextjs.org/docs/app/building-your-application/routing/defining-routes">Routing: Defining Routes</a></li>
<li><a href="https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts">Routing: Pages and Layouts</a></li>
<li><a href="https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming">Routing: Loading UI and Streaming</a></li>
<li><a href="https://nextjs.org/docs/app/building-your-application/routing/error-handling">Routing: Error Handling</a></li>
<li><a href="https://nextjs.org/docs/app/api-reference/file-conventions/not-found">File Conventions: not-found.js</a></li>
<li><a href="https://nextjs.org/docs/app/api-reference/functions/not-found">Functions: notFound</a></li>
</ol>

</body>
</html>
  