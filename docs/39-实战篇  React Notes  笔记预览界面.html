
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>39-实战篇  React Notes  笔记预览界面</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>本篇我们来实现右侧笔记预览部分。</p>
<h2>笔记预览</h2>
<p>当点击笔记的时候，可以查看该笔记的内容：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1376db7d8e4047c4bda9bf7c2dfca36f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2188&h=1316&s=237030&e=png&b=ffffff" alt="image.png"></p>
<p>按照我们之前的设计，当点击左侧笔记列表的时候，会导航至对应的 <code>/note/xxxx</code>路由，所以我们再新建一个 <code>app/note/[id]/page.js</code>文件，代码如下：</p>
<pre><code class="language-jsx">import Note from &#39;@/components/Note&#39;
import {getNote} from &#39;@/lib/redis&#39;;

export default async function Page({ params }) {
  // 动态路由 获取笔记 id
  const noteId = params.id;
  const note = await getNote(noteId)

  // 为了让 Suspense 的效果更明显
  const sleep = ms =&gt; new Promise(r =&gt; setTimeout(r, ms));
  await sleep(5000);

  if (note == null) {
    return (
      &lt;div className=&quot;note--empty-state&quot;&gt;
        &lt;span className=&quot;note-text--empty-state&quot;&gt;
          Click a note on the left to view something! 🥺
        &lt;/span&gt;
      &lt;/div&gt;
    )
  }

  return &lt;Note noteId={noteId} note={note} /&gt;
}
</code></pre>
<p>还记得上篇总结的最佳实践吗？用到数据请求的地方，考虑一下是否需要用 <code>Suspense</code> 和 <code>loading.js</code>。这里就是一个很适合用 <code>loading.js</code> 的地方，我们再添加一个 <code>app/note/[id]/loading.js</code>文件，代码如下：</p>
<pre><code class="language-javascript">export default function NoteSkeleton() {
  return (
    &lt;div
      className=&quot;note skeleton-container&quot;
      role=&quot;progressbar&quot;
      aria-busy=&quot;true&quot;
    &gt;
      &lt;div className=&quot;note-header&quot;&gt;
        &lt;div
          className=&quot;note-title skeleton&quot;
          style={{ height: &#39;3rem&#39;, width: &#39;65%&#39;, marginInline: &#39;12px 1em&#39; }}
        /&gt;
        &lt;div
          className=&quot;skeleton skeleton--button&quot;
          style={{ width: &#39;8em&#39;, height: &#39;2.5em&#39; }}
        /&gt;
      &lt;/div&gt;
      &lt;div className=&quot;note-preview&quot;&gt;
        &lt;div className=&quot;skeleton v-stack&quot; style={{ height: &#39;1.5em&#39; }} /&gt;
        &lt;div className=&quot;skeleton v-stack&quot; style={{ height: &#39;1.5em&#39; }} /&gt;
        &lt;div className=&quot;skeleton v-stack&quot; style={{ height: &#39;1.5em&#39; }} /&gt;
        &lt;div className=&quot;skeleton v-stack&quot; style={{ height: &#39;1.5em&#39; }} /&gt;
        &lt;div className=&quot;skeleton v-stack&quot; style={{ height: &#39;1.5em&#39; }} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>我们在 <code>page.js</code>中引入了<code> &lt;Note&gt;</code> 组件，<code>components/Note.js</code>的代码如下：</p>
<pre><code class="language-jsx">import dayjs from &#39;dayjs&#39;;
import NotePreview from &#39;@/components/NotePreview&#39;
import EditButton from &#39;@/components/EditButton&#39;
export default function Note({ noteId, note }) {
  const { title, content, updateTime } = note

  return (
    &lt;div className=&quot;note&quot;&gt;
      &lt;div className=&quot;note-header&quot;&gt;
        &lt;h1 className=&quot;note-title&quot;&gt;{title}&lt;/h1&gt;
        &lt;div className=&quot;note-menu&quot; role=&quot;menubar&quot;&gt;
          &lt;small className=&quot;note-updated-at&quot; role=&quot;status&quot;&gt;
            Last updated on {dayjs(updateTime).format(&#39;YYYY-MM-DD hh:mm:ss&#39;)}
          &lt;/small&gt;
            &lt;EditButton noteId={noteId}&gt;Edit&lt;/EditButton&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;NotePreview&gt;{content}&lt;/NotePreview&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>这里我们把预览的部分又单独抽离成了一个 <code>&lt;NotePreview&gt;</code> 组件，之所以抽离，是考虑到在编辑界面复用。<code>components/NotePreview.js</code>的代码如下：</p>
<pre><code class="language-javascript">import {marked} from &#39;marked&#39;
import sanitizeHtml from &#39;sanitize-html&#39;

const allowedTags = sanitizeHtml.defaults.allowedTags.concat([
  &#39;img&#39;,
  &#39;h1&#39;,
  &#39;h2&#39;,
  &#39;h3&#39;
])
const allowedAttributes = Object.assign(
  {},
  sanitizeHtml.defaults.allowedAttributes,
  {
    img: [&#39;alt&#39;, &#39;src&#39;]
  }
)

export default function NotePreview({ children }) {
  return (
    &lt;div className=&quot;note-preview&quot;&gt;
      &lt;div
        className=&quot;text-with-markdown&quot;
        dangerouslySetInnerHTML={{
          __html: sanitizeHtml(marked(children || &#39;&#39;), {
            allowedTags,
            allowedAttributes
          })
        }}
      /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>其中，<a href="https://www.npmjs.com/package/marked">marked</a> 是一个把 markdown 转换为 HTML 的库，<a href="https://www.npmjs.com/package/sanitize-html">sanitize-html</a> 用于清理 HTML，比如删除一些不良的写法，转义特殊字符等。因为用到了这两个库，我们还需要安装一下：</p>
<pre><code class="language-bash">npm i marked sanitize-html
</code></pre>
<p>此时页面已经可以正常运行了，效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a67f7d6f5bac4059ae96c59d3689b0d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1031&h=642&s=131947&e=gif&f=47&b=f4f6f9" alt="笔记预览.gif"></p>
<h2>原理解析</h2>
<h3>RSC Payload</h3>
<p>现在让我们多点击几次左侧的笔记列表，切换查看不同的笔记。你会发现，页面的地址虽然发生了变化，但页面并没有重新加载，但是页面的内容确实发生了变化，Next.js 是怎么实现的呢？</p>
<p>让我们查看下点击笔记时的请求（执行 <code>npm run start</code>时）：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e367cd4bb7b4b06a9fd94555461ac2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3610&h=1678&s=675860&e=png&b=fdfdfd" alt="截屏2023-12-16 下午7.58.57.png"></p>
<p>点击笔记的时候，我们请求了对应路由的地址，比如我们点击第一篇笔记的时候，这篇笔记的 <code>noteId</code> 为 <code>1702459188837</code>，发出的请求地址就对应为 <code>http://localhost:3000/note/1702459188837?_rsc=9ehs5</code>，Chrome 标注这条请求的 Type 是 fetch，返回的数据为：</p>
<pre><code class="language-javascript">3:I[5613,[],&quot;&quot;]
5:I[1778,[],&quot;&quot;]
4:[&quot;id&quot;,&quot;1702459188837&quot;,&quot;d&quot;]
0:[&quot;S5DEOJMw4dANsj-nNd4RK&quot;,[[&quot;children&quot;,&quot;note&quot;,[&quot;note&quot;,{&quot;children&quot;:[[&quot;id&quot;,&quot;1702459188837&quot;,&quot;d&quot;],{&quot;children&quot;:[&quot;__PAGE__&quot;,{}]}]}],[&quot;note&quot;,{&quot;children&quot;:[[&quot;id&quot;,&quot;1702459188837&quot;,&quot;d&quot;],{&quot;children&quot;:[&quot;__PAGE__&quot;,{},[&quot;$L1&quot;,&quot;$L2&quot;,null]]},[&quot;$&quot;,&quot;$L3&quot;,null,{&quot;parallelRouterKey&quot;:&quot;children&quot;,&quot;segmentPath&quot;:[&quot;children&quot;,&quot;note&quot;,&quot;children&quot;,&quot;$4&quot;,&quot;children&quot;],&quot;loading&quot;:[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;note skeleton-container&quot;,&quot;role&quot;:&quot;progressbar&quot;,&quot;aria-busy&quot;:&quot;true&quot;,&quot;children&quot;:[[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;note-header&quot;,&quot;children&quot;:[[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;note-title skeleton&quot;,&quot;style&quot;:{&quot;height&quot;:&quot;3rem&quot;,&quot;width&quot;:&quot;65%&quot;,&quot;marginInline&quot;:&quot;12px 1em&quot;}}],[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;skeleton skeleton--button&quot;,&quot;style&quot;:{&quot;width&quot;:&quot;8em&quot;,&quot;height&quot;:&quot;2.5em&quot;}}]]}],[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;note-preview&quot;,&quot;children&quot;:[[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;skeleton v-stack&quot;,&quot;style&quot;:{&quot;height&quot;:&quot;1.5em&quot;}}],[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;skeleton v-stack&quot;,&quot;style&quot;:{&quot;height&quot;:&quot;1.5em&quot;}}],[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;skeleton v-stack&quot;,&quot;style&quot;:{&quot;height&quot;:&quot;1.5em&quot;}}],[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;skeleton v-stack&quot;,&quot;style&quot;:{&quot;height&quot;:&quot;1.5em&quot;}}],[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;skeleton v-stack&quot;,&quot;style&quot;:{&quot;height&quot;:&quot;1.5em&quot;}}]]}]]}],&quot;loadingStyles&quot;:[],&quot;loadingScripts&quot;:[],&quot;hasLoading&quot;:true,&quot;error&quot;:&quot;$undefined&quot;,&quot;errorStyles&quot;:&quot;$undefined&quot;,&quot;errorScripts&quot;:&quot;$undefined&quot;,&quot;template&quot;:[&quot;$&quot;,&quot;$L5&quot;,null,{}],&quot;templateStyles&quot;:&quot;$undefined&quot;,&quot;templateScripts&quot;:&quot;$undefined&quot;,&quot;notFound&quot;:&quot;$undefined&quot;,&quot;notFoundStyles&quot;:&quot;$undefined&quot;,&quot;styles&quot;:null}]]},[&quot;$&quot;,&quot;$L3&quot;,null,{&quot;parallelRouterKey&quot;:&quot;children&quot;,&quot;segmentPath&quot;:[&quot;children&quot;,&quot;note&quot;,&quot;children&quot;],&quot;loading&quot;:&quot;$undefined&quot;,&quot;loadingStyles&quot;:&quot;$undefined&quot;,&quot;loadingScripts&quot;:&quot;$undefined&quot;,&quot;hasLoading&quot;:false,&quot;error&quot;:&quot;$undefined&quot;,&quot;errorStyles&quot;:&quot;$undefined&quot;,&quot;errorScripts&quot;:&quot;$undefined&quot;,&quot;template&quot;:[&quot;$&quot;,&quot;$L5&quot;,null,{}],&quot;templateStyles&quot;:&quot;$undefined&quot;,&quot;templateScripts&quot;:&quot;$undefined&quot;,&quot;notFound&quot;:&quot;$undefined&quot;,&quot;notFoundStyles&quot;:&quot;$undefined&quot;,&quot;styles&quot;:null}]],[null,&quot;$L6&quot;]]]]
6:[[&quot;$&quot;,&quot;meta&quot;,&quot;0&quot;,{&quot;name&quot;:&quot;viewport&quot;,&quot;content&quot;:&quot;width=device-width, initial-scale=1&quot;}],[&quot;$&quot;,&quot;meta&quot;,&quot;1&quot;,{&quot;charSet&quot;:&quot;utf-8&quot;}],[&quot;$&quot;,&quot;link&quot;,&quot;2&quot;,{&quot;rel&quot;:&quot;icon&quot;,&quot;href&quot;:&quot;/favicon.ico&quot;,&quot;type&quot;:&quot;image/x-icon&quot;,&quot;sizes&quot;:&quot;16x16&quot;}]]
1:null
7:I[5250,[&quot;250&quot;,&quot;static/chunks/250-3c648b94097e3c7b.js&quot;,&quot;156&quot;,&quot;static/chunks/app/note/%5Bid%5D/page-5070a024863ac55b.js&quot;],&quot;&quot;]
2:[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;note&quot;,&quot;children&quot;:[[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;note-header&quot;,&quot;children&quot;:[[&quot;$&quot;,&quot;h1&quot;,null,{&quot;className&quot;:&quot;note-title&quot;,&quot;children&quot;:&quot;ea molestias&quot;}],[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;note-menu&quot;,&quot;role&quot;:&quot;menubar&quot;,&quot;children&quot;:[[&quot;$&quot;,&quot;small&quot;,null,{&quot;className&quot;:&quot;note-updated-at&quot;,&quot;role&quot;:&quot;status&quot;,&quot;children&quot;:[&quot;Last updated on &quot;,&quot;2023-12-13 05:19:48&quot;]}],[&quot;$&quot;,&quot;$L7&quot;,null,{&quot;href&quot;:&quot;/note/edit/1702459188837&quot;,&quot;className&quot;:&quot;link--unstyled&quot;,&quot;children&quot;:[&quot;$&quot;,&quot;button&quot;,null,{&quot;className&quot;:&quot;edit-button edit-button--outline&quot;,&quot;role&quot;:&quot;menuitem&quot;,&quot;children&quot;:&quot;Edit&quot;}]}]]}]]}],[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;note-preview&quot;,&quot;children&quot;:[&quot;$&quot;,&quot;div&quot;,null,{&quot;className&quot;:&quot;text-with-markdown&quot;,&quot;dangerouslySetInnerHTML&quot;:{&quot;__html&quot;:&quot;&lt;p&gt;et iusto sed quo iure&lt;/p&gt;\n&quot;}}]}]]}]
</code></pre>
<p>注：如果你用 Chrome 查看数据的时候，发现无法加载响应数据，那换成其他浏览器如火狐试试。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e4946be63d4c19a24db13eb39ff43f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1428&h=324&s=31290&e=png&b=282828" alt="image.png"></p>
<p>这个数据就被称为 <code>React Server Components Payload</code>，简称 <code>RSC Payload</code>，其实你看这个地址的参数<code>?rsc=xxxx</code>其实就暗示了它跟 RSC 相关。查看返回的数据 ，你会发现这个数据很奇怪，既不是我们常见的 HTML、XML，也不是什么其他格式，这就是 React 定义的一种特殊的格式。</p>
<p>还记得<a href="https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-19">《 缓存篇 | Caching》</a>中讲到 RSC Payload 包含哪些信息吗：</p>
<ol>
<li>服务端组件的渲染结果</li>
<li>客户端组件的占位位置和引用文件</li>
<li>从服务端组件传给客户端组件的数据</li>
</ol>
<p>比如以 <code>0:</code> 开头的那行，根据其中的内容，可以判断出渲染的是笔记加载时的骨架图。以 <code>2:</code>开头的那行，渲染的则是笔记的具体内容。</p>
<p><strong>使用这种格式的优势在于它针对流做了优化，数据是分行的，它们可以以流的形式逐行从服务端发送给客户端，客户端可以逐行解析 RSC Payload，渐进式渲染页面。</strong></p>
<p>比如客户端收到 <code>0:</code>开头的这行，于是开始渲染骨架图。收到 <code>7:</code>开头的这行，发现需要下载 <code>static/chunks/app/note/[id]/page-5070a024863ac55b.js</code>，于是开始请求该 JS 文件，查看刚才的请求，也确实请求了该文件。收到 <code>2:</code>开头的这行，于是开始渲染笔记的具体内容。</p>
<p>因为我们特地设置了请求时间大于 5s，所以 <code>2:</code>开头的那行数据返回的时候肯定比 <code>0:</code>晚了 <code>5s</code>以上，这条请求的时长也确实大于了 5s，这也应证了 RSC Payload 服务端是逐行返回，客户端是逐行解析、渐进式渲染的。</p>
<p>注：你可能发现，还有一个 404 的 RSC Payload 请求，它请求的地址是 <code>/note/edit/170245918883</code>，这是因为渲染出的 Edit 按钮用的是 Link 组件，Link 组件有预获取，所以触发了请求，但因为这个路由我们还没写，所以出现了 404 错误。其实跟本篇要讲的内容无关。</p>
<p>现在我们将 <code>http://localhost:3000/note/1702459188837?_rsc=9ehs5</code>这个地址在新标签页中打开，你会发现还是这个请求地址，返回的却是 HTML：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a2f596cd23a475c834da5116271c260~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3578&h=1122&s=553000&e=png&b=fdfdfd" alt="image.png"></p>
<p>至于怎么实现的，想必你也想到了，两个请求虽然地址一样，但请求头不一样。这是返回 RSC Payload 的请求头：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9825f626460c464cb18f5a17dc736c6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1670&h=1210&s=369427&e=png&b=282828" alt="截屏2023-12-16 下午8.45.08.png"></p>
<p>这是返回 HTML 的请求头：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee4c16e1e23b4ba8a19ffcd8249dfd31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2530&h=948&s=300784&e=png&b=292929" alt="image.png"></p>
<p>那在这个 HTML 中又是怎么实现初始加载骨架图，然后 5s 后加载笔记数据的呢？</p>
<p>这节在上一篇已经讲过了。简单的来说，该 HTML 也是流式传输，会先后返回骨架图和笔记数据：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;body&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;div class=&quot;main&quot;&gt;
                &lt;section class=&quot;col note-viewer&quot;&gt;
                    &lt;!-- 笔记加载时的骨架图 --&gt;
                    &lt;template id=&quot;B:1&quot;&gt;&lt;/template&gt;
                    &lt;div class=&quot;note skeleton-container&quot; role=&quot;progressbar&quot; aria-busy=&quot;true&quot;&gt;
                        &lt;div class=&quot;note-header&quot;&gt;
                            &lt;div class=&quot;note-title skeleton&quot; style=&quot;height:3rem;width:65%;margin-inline:12px 1em&quot;&gt;&lt;/div&gt;
                            &lt;div class=&quot;skeleton skeleton--button&quot; style=&quot;width:8em;height:2.5em&quot;&gt;&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;note-preview&quot;&gt;
                            &lt;div class=&quot;skeleton v-stack&quot; style=&quot;height:1.5em&quot;&gt;&lt;/div&gt;
                            &lt;div class=&quot;skeleton v-stack&quot; style=&quot;height:1.5em&quot;&gt;&lt;/div&gt;
                            &lt;div class=&quot;skeleton v-stack&quot; style=&quot;height:1.5em&quot;&gt;&lt;/div&gt;
                            &lt;div class=&quot;skeleton v-stack&quot; style=&quot;height:1.5em&quot;&gt;&lt;/div&gt;
                            &lt;div class=&quot;skeleton v-stack&quot; style=&quot;height:1.5em&quot;&gt;&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;!--/$--&gt;
                &lt;/section&gt;
            &lt;/div&gt;
        &lt;/div&gt;
      	// ...
        &lt;div hidden id=&quot;S:1&quot;&gt;
            &lt;div class=&quot;note&quot;&gt;
                &lt;div class=&quot;note-header&quot;&gt;
                    &lt;h1 class=&quot;note-title&quot;&gt;ea molestias&lt;/h1&gt;
                    &lt;div class=&quot;note-menu&quot; role=&quot;menubar&quot;&gt;
                        &lt;small class=&quot;note-updated-at&quot; role=&quot;status&quot;&gt;Last updated on 
                        &lt;!-- --&gt;
                        2023-12-13 05:19:48&lt;/small&gt;
                        &lt;a class=&quot;link--unstyled&quot; href=&quot;/note/edit/1702459188837&quot;&gt;
                            &lt;button class=&quot;edit-button edit-button--outline&quot; role=&quot;menuitem&quot;&gt;Edit&lt;/button&gt;
                        &lt;/a&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;note-preview&quot;&gt;
                    &lt;div class=&quot;text-with-markdown&quot;&gt;
                        &lt;p&gt;et iusto sed quo iure&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;script&gt;
            // 替换内容
            $RC = function(b, c, e) { // ... }
            $RC(&quot;B:1&quot;, &quot;S:1&quot;)
        &lt;/script&gt;
        // ...
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>我们接着讲 RSC Payload，那客户端获取到 RSC Payload 后还干了什么呢？其实就是根据 RSC Payload 重新渲染组件树，修改 DOM。但使用 RSC Payload 的好处在于组件树中的状态依然会被保持，比如左侧笔记列表的展开和收回就是一种客户端状态，当你新增笔记、删除笔记时，虽然组件树被重新渲染，但是客户端的状态依然会继续保持了。</p>
<p>这也被认为是 SSR 和 RSC 的最大区别，其实现的关键就在于服务端组件没有被渲染成 HTML，而是一种特殊的格式（RSC Payload）。这里让我们再复习下 SSR（传统的 SSR，想想 Pages Router 下的 SSR 实现） 和 RSC 的区别：</p>
<ol>
<li>RSC 的代码不会发送到客户端，但传统 SSR 所有组件的代码都会被发送到客户端</li>
<li>RSC 可以在组件树中任意位置获取后端，传统 SSR 只能在顶层（getServerSideProps）访问后端</li>
<li>服务器组件可以重新获取，而不会丢失其树内的客户端状态</li>
</ol>
<p>注：这里虽然比较了 SSR 和 RSC，但并不是说明两者是冲突的，其实 SSR 和 RSC 是互补关系，是可以一起使用的，Next.js 中两者就是一起使用的。</p>
<h3>路由缓存</h3>
<p>现在让我们再多点击几次左侧的笔记列表，切换查看不同的笔记，你会发现有一件奇怪的事情（这个 GIF 有 30 多秒）：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e1242d79fa149eb9dc99b75b1663b47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1031&h=642&s=628380&e=gif&f=223&b=f3f6f9" alt="路由缓存.gif"></p>
<p>点击切换不同的笔记，你会发现同样一条笔记，有时会触发数据的重新请求（出现了骨架图），但有的时候又没有，但有的时候又会重新出现（又出现了骨架图），这是为什么吗？</p>
<p>这就是 Next.js 提供的客户端路由缓存功能，客户端会缓存 RSC Payload 数据，所以当点击笔记后很快再次点击，这时就会从缓存中获取数据，那么问题来了，缓存的失效逻辑还记得吗？具体会缓存多久呢？我们在<a href="https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-20">缓存篇</a>中和大家讲过，回忆下基础知识：</p>
<p>路由缓存存放在浏览器的临时缓存中，有两个因素决定了路由缓存的持续时间：</p>
<ul>
<li><strong>Session，缓存在导航期间会持续存在，当页面刷新的时候会被清除</strong></li>
<li><strong>自动失效期：单个路由段会在特定时长后自动失效，如果路由是静态渲染，持续 5 分钟，如果是动态渲染，持续 30s</strong></li>
</ul>
<p>这个例子中因为我们用的是动态路由，是动态渲染，缓存持续 30s，所以首次点击笔记获取 RSC Payload 数据 30s 后再点击就会重新获取 RSC Payload。</p>
<p>小问题：以这个项目为例，如果点击笔记的时间算成 0s，因为请求时长大于 5s，假设 RSC Payload 在第 5s 完全返回，下次路由缓存失效重新获取的时间是大概在 30s 后还是 35s 后呢？</p>
<p>答案是 30s。以 RSC Payload 的返回时间为准，RSC Payload 是逐行返回的，所以点击的时候很快就有返回了。</p>
<h2>总结</h2>
<p>那么今天的内容就结束了，本篇的内容并不多，主要是通过笔记预览这个例子，在实际开发中加深对 RSC Payload 和路由缓存的理解。</p>
<p>本篇的代码我已经上传到<a href="https://github.com/mqyqingfeng/next-react-notes-demo/tree/main">代码仓库</a>的 Day3 分支：<a href="https://github.com/mqyqingfeng/next-react-notes-demo/tree/day3">https://github.com/mqyqingfeng/next-react-notes-demo/tree/day3</a>，直接使用的时候不要忘记在本地开启 Redis。</p>

</body>
</html>
  