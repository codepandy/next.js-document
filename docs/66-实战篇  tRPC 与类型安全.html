
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>66-实战篇  tRPC 与类型安全</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>我们先从 RPC 开始说起。</p>
<p>RPC（Remote Procedure Call），中文译为“<strong>远程过程调用</strong>”，主要用于在远程计算机之间执行操作。它允许一个程序调用另一个程序，就像调用本地服务一样。</p>
<p>其实这个介绍已经很精炼的概括了 RPC，但对于初学者尤其是前端同学，这个介绍可能依然有些不明所以。</p>
<p>其实提 RPC 一定要讲分布式，对于大型网站而言，子系统部署在不同的服务器上，但又需要相互协作，于是诞生了 RPC 这个技术概念。它主要解决 2 个问题：</p>
<ol>
<li>分布式系统的服务之间的调用问题</li>
<li>远程调用时，最好能够像本地调用一样方便，让调用者感知不到远程调用的逻辑</li>
</ol>
<blockquote>
<p>想想 Server Actions，它的本质其实就是 RPC，调用的时候就像本地调用，实际上是客户端调用服务端</p>
</blockquote>
<p>至于底层是使用 HTTP 还是 Socket 那是 RPC 框架的事情。</p>
<p>而 <a href="https://trpc.io/">tRPC</a> 是一个基于 TypeScript 的 RPC 框架，不过我们使用 tRPC 倒不是要解决分布式问题，而是为了解决客户端和服务端之间共享类型的问题。引用 tRPC 首页的介绍图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b5a472cf5a403bbb4f19f0273c7f55~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2954&h=1408&s=4017690&e=gif&f=487&b=131211" alt="v10-dark-landscape.gif"></p>
<p>左边是服务端代码，右边是客户端代码，当你修改了服务端的请求参数字段，TypeScript 立刻就在客户端代码提示出了字段错误。这种客户端和服务端之间的类型共享就叫做端到端类型安全（End-to-end typesafe）。</p>
<p>本篇为大家讲解 Next.js App Router 如何集成 tRPC。</p>
<blockquote>
<p>不过我个人建议：如果你之前没有用过或喜欢 tRPC，那就不要学了。末尾会给解释。</p>
</blockquote>
<h2>tRPC 与 Next.js</h2>
<h3>1. 项目初始化</h3>
<p>初始化项目：</p>
<pre><code class="language-bash">npx create-next-app@latest
</code></pre>
<p>选择 TypeScript、App Router：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43bcab9815264e05a02a16b6fde2bd22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1566&h=390&s=140599&e=png&b=1e1e1e" alt="image.png"></p>
<p>安装 tRPC 依赖项：</p>
<pre><code class="language-bash">npm install @trpc/server@next @trpc/client@next @trpc/react-query@next @trpc/next@next @tanstack/react-query@latest zod
</code></pre>
<h3>2. 定义接口</h3>
<p>新建 <code>server/trpc.ts</code>，代码如下：</p>
<pre><code class="language-javascript">import { initTRPC } from &quot;@trpc/server&quot;;
// Avoid exporting the entire t-object
// since it&#39;s not very descriptive.
// For instance, the use of a t variable
// is common in i18n libraries.
const t = initTRPC.create();
// Base router and procedure helpers
export const router = t.router;
export const procedure = t.procedure;
export const createCallerFactory = t.createCallerFactory;
</code></pre>
<p>新建 <code>server/index.ts</code>，代码如下：</p>
<pre><code class="language-javascript">import { z } from &quot;zod&quot;;
import { procedure, router } from &quot;./trpc&quot;;

export const appRouter = router({
  getTodos: procedure.query(() =&gt; {
    return {
      todos: [&quot;运动&quot;, &quot;冥想&quot;, &quot;阅读&quot;],
    };
  }),
});

// export type definition of API
export type AppRouter = typeof appRouter;
</code></pre>
<p>这里就是具体定义 trpc 方法的地方，我们声明了一个 <code>getTodos</code> 方法。</p>
<p>新建 <code>app/api/trpc/[trpc]/route.ts</code>，代码如下：</p>
<pre><code class="language-javascript">import { fetchRequestHandler } from &quot;@trpc/server/adapters/fetch&quot;;
import { appRouter } from &quot;@/server&quot;;

function handler(req: Request) {
  return fetchRequestHandler({
    endpoint: &quot;/api/trpc&quot;,
    req,
    router: appRouter,
    createContext: () =&gt; ({}),
  });
}
export { handler as GET, handler as POST };
</code></pre>
<p>此时访问 <a href="http://localhost:3000/api/trpc/getTodos">http://localhost:3000/api/trpc/getTodos</a>，就可以查看到接口数据：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d546049f33d4946abaa9f6f2eb78c76~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1452&h=274&s=47794&e=png&b=f9f9f9" alt="image.png"></p>
<h3>3. tRPC Client</h3>
<p>新建 <code>app/_trpc/client.ts</code>，代码如下：</p>
<pre><code class="language-javascript">import { type AppRouter } from &quot;@/server&quot;;
import { createTRPCReact } from &quot;@trpc/react-query&quot;;

export const trpc = createTRPCReact&lt;AppRouter&gt;({});
</code></pre>
<p>新建 <code>app/_trpc/Provider.tsx</code>，代码如下：</p>
<pre><code class="language-jsx">&quot;use client&quot;;
import { QueryClient, QueryClientProvider } from &quot;@tanstack/react-query&quot;;
import { httpBatchLink } from &quot;@trpc/client&quot;;
import React, { useState } from &quot;react&quot;;

import { trpc } from &quot;./client&quot;;

export default function Provider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() =&gt; new QueryClient({}));
  const [trpcClient] = useState(() =&gt;
    trpc.createClient({
      links: [
        httpBatchLink({
          url: &quot;http://localhost:3000/api/trpc&quot;,
        }),
      ],
    })
                               );
  return (
    &lt;trpc.Provider client={trpcClient} queryClient={queryClient}&gt;
      &lt;QueryClientProvider client={queryClient}&gt;{children}&lt;/QueryClientProvider&gt;
    &lt;/trpc.Provider&gt;
  );
}
</code></pre>
<p>修改 <code>app/layout.tsx</code>，代码如下：</p>
<pre><code class="language-javascript">import type { Metadata } from &quot;next&quot;;
import { Inter } from &quot;next/font/google&quot;;
import &quot;./globals.css&quot;;
import Provider from &quot;@/app/_trpc/Provider&quot;;
const inter = Inter({ subsets: [&quot;latin&quot;] });

export const metadata: Metadata = {
  title: &quot;Create Next App&quot;,
  description: &quot;Generated by create next app&quot;,
};

export default function RootLayout({
  children,
}: Readonly&lt;{
  children: React.ReactNode;
}&gt;) {
  return (
    &lt;html lang=&quot;en&quot;&gt;
      &lt;body className={inter.className}&gt;
        &lt;Provider&gt;{children}&lt;/Provider&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<p>新建 <code>app/_trpc/serverclient.ts</code>，代码如下：</p>
<pre><code class="language-javascript">import { appRouter } from &quot;@/server&quot;;
import { createCallerFactory } from &quot;@/server/trpc&quot;;
import { httpBatchLink } from &quot;@trpc/client&quot;;

const createCaller = createCallerFactory(appRouter);

export const serverClient = createCaller({
  links: [
    httpBatchLink({
      url: &quot;http://localhost:3000/api/trpc&quot;,
    }),
  ],
});
</code></pre>
<h3>4. 服务端调用示例</h3>
<p>当需要服务端渲染的时候，导入 <code>app/_trpc/serverclient</code> 调用方法。</p>
<p>修改 <code>app/page.tsx</code>，代码如下：</p>
<pre><code class="language-javascript">import { serverClient } from &quot;@/app/_trpc/serverclient&quot;;

export default async function Home() {
  const todos = await serverClient.getTodos();
  return &lt;div&gt;{JSON.stringify(todos)}&lt;/div&gt;;
}
</code></pre>
<p>浏览器效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07f1deed87084f3b8ebf63ac632a3d1f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1146&h=236&s=31769&e=png&b=fefefe" alt="image.png"></p>
<h3>5. 客户端调用示例</h3>
<p>当客户端调用接口的时候，导入 <code>app/_trpc/client</code>调用方法。</p>
<p>新建 <code>app/todos/page.js</code>，代码如下：</p>
<pre><code class="language-javascript">&quot;use client&quot;;

import { trpc } from &quot;@/app/_trpc/client&quot;;

export default function page() {
  const getTodos = trpc.getTodos.useQuery();

  return (
    &lt;main&gt;
      &lt;div&gt;{JSON.stringify(getTodos, null, &quot;\t&quot;)}&lt;/div&gt;
    &lt;/main&gt;
  );
}
</code></pre>
<p>浏览器效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/668246f72f2e4fbb819f9f8fdda49ab8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1512&h=315&s=125303&e=gif&f=13&b=fdfdfd" alt="29.gif"></p>
<h2>不一定非要用 tRPC</h2>
<p>首先，正如 tRPC 官方网站首页的介绍，tRPC 的最大特点是解决了全栈应用端到端类型安全的问题：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1196109fc53a4844b179e8cdc593ac4f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2826&h=592&s=239839&e=png&b=ffffff" alt="image.png"></p>
<p>但是 Next.js 的 Server Actions 已经解决了这一问题（实际上 Server Actions 和 tRPC 本质都是 RPC），当 Server Actions 搭配 TypeScript 的时候，已经能够给出准确的类型。</p>
<p>而且 Next.js App Router 已经出来 2 年了，tRPC 官方至今没有给出权威的接入 App Router 的教程（以上接入的教程更多是参考业界的实践总结而来）。</p>
<p>为什么至今没有呢？于是就有人发起了 <a href="https://github.com/trpc/trpc/issues/5277">docs: Provide examples using tRPC with Next.js app router</a> 的 Issue，而 tRPC 的作者在 5 月给出的回应是：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c9286c440dc41d3855ca4ff51605b43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2360&h=796&s=240004&e=png&b=ffffff" alt="截屏2024-07-04 21.44.15.png"></p>
<p>也就是说，因为 RSC 和 Server Actions 解决了不少创建 trpc 时要解决的问题，所以作者也不知道人们到底要怎么用 tRPC。</p>
<p>最后，tRPC 学习门槛高。毕竟 rpc 并不是一个小概念，它涉及的内容很多，使用 tRPC 还要重新学习 API 比如如何做校验、做鉴权、做缓存、做跨域、错误处理等等，对于没有经验的人又要踩上一批坑。</p>
<p>所以我个人觉得如果你之前没有用过或喜欢 tRPC，那就不用学了，觉得 tRPC 听起来帅就更没必要了。</p>
<p>但这并不是说 tRPC 一点用也没有，实际上，tRPC 官方给出了结合 Next.js Server Actions 的<a href="https://trpc.io/blog/trpc-actions">教程</a>。因为 tRPC 本身的 API 做的不错，所以使用 tRPC 定义 Server Actions 可以使用 tRPC 的如输入验证、身份验证和授权、输出验证、数据转换器等功能。</p>
<blockquote>
<p>个人意见，仅供参考，欢迎留言讨论</p>
</blockquote>
<h2>参考链接</h2>
<ol>
<li><a href="https://www.youtube.com/watch?v=qCLV0Iaq9zU&t=12s&ab_channel=JackHerrington">https://www.youtube.com/watch?v=qCLV0Iaq9zU&amp;t=12s&amp;ab_channel=JackHerrington</a></li>
</ol>

</body>
</html>
  