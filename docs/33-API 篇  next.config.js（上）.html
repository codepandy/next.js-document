
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>33-API 篇  next.config.js（上）</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>Next.js 可以通过根目录的 <code>next.config.js</code> 进行配置：</p>
<pre><code class="language-javascript">/** @type {import(&#39;next&#39;).NextConfig} */
const nextConfig = {
  /* config options here */
}
 
module.exports = nextConfig
</code></pre>
<p>正如文件的扩展名是 <code>.js</code>，<code>next.config.js</code> 是一个常规的 Node.js 模块，而不是一个 JSON 文件。它会在 Next.js server 和构建阶段被用到，并且不包含在浏览器构建中（代码不会打包到客户端）。</p>
<p>如果你需要 ECMAScript 模块，你可以使用 <code>next.config.mjs</code>：</p>
<pre><code class="language-javascript">/**
 * @type {import(&#39;next&#39;).NextConfig}
 */
const nextConfig = {
  /* config options here */
}
 
export default nextConfig
</code></pre>
<p>你也可以使用一个函数：</p>
<pre><code class="language-javascript">export default (phase, { defaultConfig }) =&gt; {
  /**
   * @type {import(&#39;next&#39;).NextConfig}
   */
  const nextConfig = {
    /* config options here */
  }
  return nextConfig
}
</code></pre>
<p>从 Next.js 12.1.0 起，你还可以使用一个异步函数：</p>
<pre><code class="language-javascript">module.exports = async (phase, { defaultConfig }) =&gt; {
  /**
   * @type {import(&#39;next&#39;).NextConfig}
   */
  const nextConfig = {
    /* config options here */
  }
  return nextConfig
}
</code></pre>
<p>其中 <code>phase</code> 表示配置加载的当前上下文。通过<a href="https://github.com/vercel/next.js/blob/5e6b008b561caf2710ab7be63320a3d549474a5b/packages/next/shared/lib/constants.ts#L19-L23">查看源码</a>，可以知道 <code>phase</code> 的值一共有 5 个：</p>
<pre><code class="language-javascript">export const PHASE_EXPORT = &#39;phase-export&#39;
export const PHASE_PRODUCTION_BUILD = &#39;phase-production-build&#39;
export const PHASE_PRODUCTION_SERVER = &#39;phase-production-server&#39;
export const PHASE_DEVELOPMENT_SERVER = &#39;phase-development-server&#39;
export const PHASE_TEST = &#39;phase-test&#39;
</code></pre>
<p>可以通过 <code>next/constants</code> 导入，根据不同的阶段进行自定义配置：</p>
<pre><code class="language-javascript">const { PHASE_DEVELOPMENT_SERVER } = require(&#39;next/constants&#39;)
 
module.exports = (phase, { defaultConfig }) =&gt; {
  if (phase === PHASE_DEVELOPMENT_SERVER) {
    return {
      /* 这里放 development 配置选项 */
    }
  }
 
  return {
    /* 除了 development 阶段的其他阶段的配置 */
  }
}
</code></pre>
<p>在这个例子中，注释行的地方就是你可以放配置的地方，实际上，Next.js 定义的配置非常多，可以查看<a href="https://github.com/vercel/next.js/blob/canary/packages/next/src/server/config-shared.ts">源码配置文件</a>。</p>
<p>然而，这些配置又都不是必须的，也没有必要清楚的了解每个配置的作用，大致看一下，有个印象即可，需要用到的时候再去细查。</p>
<p>因为要讲解的配置有 36 个，内容繁琐细节且庞大，所以 <code>next.config.js</code> 的配置部分拆分为上下两篇。上篇讲解请求相关的 headers、redirects、rewrites，这是 Next.js 中常用的配置，且内容有很多相似之处，放在一起方便触类旁通。下篇讲解剩余的 33 个配置，每个配置内容都不多，了解即可。</p>
<p>现在让我们开始学习吧！</p>
<h2>1. headers</h2>
<h3>1.1. 介绍</h3>
<p>Headers 用于设置自定义 HTTP 标头，使用 <code>next.config.js</code> 的 <code>headers</code>字段：</p>
<pre><code class="language-javascript">module.exports = {
  async headers() {
    return [
      {
        source: &#39;/about&#39;,
        headers: [
          {
            key: &#39;x-custom-header&#39;,
            value: &#39;my custom header value&#39;,
          },
          {
            key: &#39;x-another-custom-header&#39;,
            value: &#39;my other custom header value&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<p>此时访问 <code>/about</code>，可以看到：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca0818d69f76450182e9e9834080e0eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2304&h=1528&s=400155&e=png&b=2a2a2a" alt="截屏2023-11-09 下午3.40.56.png"></p>
<p><code>headers</code>是一个异步函数，该函数返回一个包含 <code>soruce</code> 和 <code>headers</code> 属性的对象数组，其中：</p>
<ul>
<li><code>source</code> 表示传入的请求路径</li>
<li><code>headers</code> 是一个包含 key 和 value 属性的响应标头对象数组</li>
</ul>
<p>除了这两个值外，还可以设置：</p>
<ul>
<li><code>basePath</code>：<code>false</code> 或者 <code>undefined</code>。当值为 <code>false</code> ，匹配时不会包含 <code>basePath</code>，只能用于外部重写</li>
<li><code>locale</code>：<code>false</code> 或者 <code>undefined</code>，匹配时是否应该包含 locale</li>
<li><code>has</code>：一个有 <code>type</code>、<code>key</code>、<code>value</code> 属性的对象数组</li>
<li><code>missing</code>：一个有 <code>type</code>、<code>key</code>、<code>value</code> 属性的对象数组</li>
</ul>
<p>headers 会在文件系统（包括页面和 <code>/public</code> 文件）之前被触发。</p>
<p>这些字段我们来一一举例介绍。</p>
<h3>1.2. source</h3>
<p>source 表示传入的请求路径，除了可以匹配具体的值，还支持三种匹配模式：</p>
<h4>路径匹配</h4>
<p>普通的路径匹配，举个例子，<code>/blog:slug</code> 会匹配 <code>/blog/hello-world</code>（无嵌套路径，也就是说 <code>/blog/hello-world/about</code>不会匹配）</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: &#39;/blog/:slug&#39;,
        headers: [
          {
            key: &#39;x-slug&#39;,
            value: &#39;:slug&#39;, // 匹配参数可以在 value 中使用
          },
          {
            key: &#39;x-slug-:slug&#39;, // 匹配参数可以在 key 中使用
            value: &#39;my other custom header value&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<p>访问 <code>/blog/hello-world</code>，可以看到：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f430b2c5e9a44a7d88dcaf32a3bdbad9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2294&h=1516&s=410172&e=png&b=2a2a2a" alt="截屏2023-11-09 下午4.00.05.png"></p>
<p>但访问 <code>/blog/hello-world/about</code>就不会有自定义标头。</p>
<h4>通配符路径匹配</h4>
<p>在参数后使用 <code>*</code> 实现通配符路径匹配，举个例子：<code>/blog/:slug*</code> 会匹配 <code>/blog/a/b/c/d/hello-world</code>：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: &#39;/blog/:slug*&#39;,
        headers: [
          {
            key: &#39;x-slug&#39;,
            value: &#39;:slug*&#39;,
          },
          {
            key: &#39;x-slug-:slug*&#39;,
            value: &#39;my other custom header value&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<p>访问 <code>/blog/hello-world/about</code>，可以看到：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72fc974d27674c02a4e40057c49cc1ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786&h=84&s=20629&e=png&b=282828" alt="image.png"></p>
<p>访问 <code>/blog/hello-world</code> 也是有的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c5756cc8262461a945a66436db9ee92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=700&h=88&s=17996&e=png&b=282828" alt="image.png"></p>
<h4>正则表达式路径匹配</h4>
<p>在参数后用括号将正则表达式括住实现正则表达式匹配，举个例子：<code>blog/:slug(\\d{1,})</code> 匹配 <code>/blog/123</code> 而不匹配 <code>/blog/abc</code></p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: &#39;/blog/:post(\\d{1,})&#39;,
        headers: [
          {
            key: &#39;x-post&#39;,
            value: &#39;:post&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<p>访问 <code>/blog/123</code>，可以看到：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0738859e301945d9967e538636722a43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=402&h=52&s=7281&e=png&b=282828" alt="image.png"></p>
<p>注意：这 8 个字符  <code>(</code>、<code>)</code>、 <code>{</code>、 <code>}</code>、 <code>:</code>、 <code>*</code>、 <code>+</code>、 <code>?</code> 都会用于正则表达式匹配，所以需要用到这些字符本身的时候，使用 <code>\\</code>转义</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async headers() {
    return [
      {
        // 匹配 `/english(default)/something`
        source: &#39;/english\\(default\\)/:slug&#39;,
        headers: [
          {
            key: &#39;x-header&#39;,
            value: &#39;value&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<h3>1.3. headers</h3>
<p>headers 无须多说，我们聊聊 headers 的覆盖行为。</p>
<p>如果两个 headers 匹配相同的路径以及设置了相同的 header key，最后一个 header 的 key 会覆盖前一个。举个例子：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: &#39;/:path*&#39;,
        headers: [
          {
            key: &#39;x-hello&#39;,
            value: &#39;there&#39;,
          },
        ],
      },
      {
        source: &#39;/hello&#39;,
        headers: [
          {
            key: &#39;x-hello&#39;,
            value: &#39;world&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<p>在这个例子中，当访问 <code>/hello</code> 时，既匹配 <code>/:path*</code>，又匹配 <code>/hello</code>，而两个 source 对应设置的 <code>x-hello</code> 的 key 值不同，因为<code>/hello</code> 是最后一个 header，所以最终的值是 <code>world</code>。</p>
<p>那如果匹配了相同的路径，但设置的  header key 不冲突呢？那就都会添加，举个例子：</p>
<pre><code class="language-javascript">module.exports = {
  async headers() {
    return [
      {
        source: &#39;/:path*&#39;,
        headers: [
          {
            key: &#39;hello&#39;,
            value: &#39;hello&#39;,
          },
          {
            key: &#39;hello2&#39;,
            value: &#39;hello2&#39;,
          }
        ],
      },
      {
        source: &#39;/hello&#39;,
        headers: [
          {
            key: &#39;hello&#39;,
            value: &#39;world&#39;,
          },
          {
            key: &#39;hello3&#39;,
            value: &#39;hello3&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<p>最终的结果为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5a1ecfec794a40b85c6684899f2914~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=248&h=128&s=11341&e=png&b=282828" alt="image.png"></p>
<h3>1.4. basePath</h3>
<p><code>basePath</code>的值为 <code>false</code> 或者 <code>undefined</code>。当值为 <code>false</code> ，匹配时不会包含 <code>basePath</code>，举个例子：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  basePath: &#39;/docs&#39;,
 
  async headers() {
    return [
      {
        source: &#39;/with-basePath&#39;, // 匹配 /docs/with-basePath
        headers: [
          {
            key: &#39;x-hello&#39;,
            value: &#39;world&#39;,
          },
        ],
      },
      {
        source: &#39;/without-basePath&#39;, // 匹配 /without-basePath
        headers: [
          {
            key: &#39;x-hello&#39;,
            value: &#39;world&#39;,
          },
        ],
        basePath: false, // 因为设置了 false
      },
    ]
  },
}
</code></pre>
<p>在这个例子中，设置了 <code>basePath</code> 为 <code>/docs</code>，正常 headers 中的 source 会匹配 basePath + source 构成的链接，除非你设置了 <code>basePath</code> 为 <code>false</code>。</p>
<h3>1.5. locale</h3>
<p><code>locale</code> 的值为 <code>false</code> 或者 <code>undefined</code>，决定匹配时是否应该包含 locale，其实效果跟 basePath 类似.</p>
<p>考虑到部分同学对 <code>locale</code> 不太熟悉，我们先简单的讲下 <code>locale</code>配置项，locale 的作用就是国际化（i18n），<code>next.config.js</code> 针对 Pages Router 提供了 i18n 配置项，注意是在 Pages Router 下，在 App Router 下 Next.js 已经不再提供直接的支持，具体内容查看小册国际化章节。</p>
<p>比如我们在 <code>pages</code> 目录下新建一个 <code>article.js</code> 文件：</p>
<pre><code class="language-javascript">// pages/article.js
export default function Home() {
  return  &lt;h1&gt;Hello Article!&lt;/h1&gt;
}
</code></pre>
<p>然后 <code>next.config.js</code> 修改配置项：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  i18n: {
    locales: [&#39;en&#39;, &#39;fr&#39;, &#39;de&#39;, &#39;zh&#39;],
    defaultLocale: &#39;zh&#39;,
  }
}
</code></pre>
<p>此时，访问 <code>/en/article</code>、<code>/fr/article</code>、<code>/de/article</code> 都会重写为 <code>/article</code>，注意是重写，就是路由地址不变，但内容是 <code>/article</code>的内容。访问 <code>/zh/article</code> 会重定向到 <code>/article</code>。</p>
<p>而如果你在 <code>app/article</code>目录下新建一个 <code>article.js</code> 文件，文件内容同上。</p>
<p>此时，访问 <code>/en/article</code>、<code>/fr/article</code>、<code>/de/article</code> 都会 404 错误。访问 <code>/zh/article</code> 会重写为 <code>/article</code>。说明在 App Router 下只有 <code>i18n.defaultLocale</code> 是生效的。</p>
<p>好了，基本介绍完毕，主要是为了让大家了解配置项中的 i18n 的作用。我们再看 headers 中的 locales 设置，举个例子：</p>
<pre><code class="language-javascript">module.exports = {
  i18n: {
    locales: [&#39;en&#39;, &#39;fr&#39;, &#39;de&#39;],
    defaultLocale: &#39;en&#39;,
  },
 
  async headers() {
    return [
      {
        // 自动处理所有的 locales
        // 也就是 `/en/with-locale`、`/fr/with-locale`、`/de/with-locale`、`/with-locale` 都会匹配
        source: &#39;/with-locale&#39;, 
        headers: [
          {
            key: &#39;x-hello&#39;,
            value: &#39;world1&#39;,
          },
        ],
      },
      {
        // 因为 locale 设置为 false，所以不会自动处理 locales
        // 也就是只匹配 `/nl/with-locale-manual`
        source: &#39;/nl/with-locale-manual&#39;,
        locale: false,
        headers: [
          {
            key: &#39;x-hello&#39;,
            value: &#39;world2&#39;,
          },
        ],
      },
      {
        // 匹配 &#39;/&#39; 因为 `en` 是 defaultLocale
        // 也就是只匹配 `/`、`/en`
        source: &#39;/en&#39;,
        locale: false,
        headers: [
          {
            key: &#39;x-hello&#39;,
            value: &#39;world3&#39;,
          },
        ],
      },
      {
        // 会转换为 /(en|fr|de)/(.*) 所以不会匹配顶层
        // 也就是 `/` 和 `/fr` 都不会匹配到
        // 如果要匹配到这两个，可以用 `/:path*`
        source: &#39;/(.*)&#39;,
        headers: [
          {
            key: &#39;x-hello&#39;,
            value: &#39;world4&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<p>注意，虽然 i18n.locales 配置在 App Router 下不生效，但这也只是导致页面出现 404 错误而已，并不会影响处理标头，即便页面 404，你可以正常的查看标头。</p>
<h3>1.6. has 和 missing</h3>
<p><code>has</code> 和 <code>missing</code> 是用来处理请求中的 header、cookie 和请求参数是否匹配某些字段，或者不匹配某些字段的时候，才应用 header。</p>
<p>举个例子，比如请求 <code>/article?id=1&amp;author=yayu</code>，<code>has</code> 可以要求请求中必须有 id 参数，或者 id 参数等于 xxx 的时候才返回某个标头。<code>missing</code> 可以要求请求中必须没有 id 参数，或者 id 参数不等于 xxx 的时候才返回某个标头。</p>
<p><code>has</code> 和 <code>missing</code> 对象有下面这些字段：</p>
<ul>
<li><code>type</code>: <code>String</code>类型，值为 <code>header</code>、<code>cookie</code>、<code>host</code>、<code>query</code> 之一</li>
<li><code>key</code>: <code>String</code>类型，所选类型（也就是上面的四种值）中要匹配的 key</li>
<li><code>value</code>： <code>String</code> 或者 <code>undefined</code>，要检查的值。如果值为 <code>undefiend</code>，任何值都不会匹配。支持使用一个类似正则的字符串捕获值的特殊部分。比如 <code>first-(?&lt;paramName&gt;.*)</code>用于匹配 <code>first-second</code>，然后就可以用 <code>:paramName</code>获取 <code>second</code> 这个值</li>
</ul>
<p>听起来有些复杂，看个例子其实就懂了：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async headers() {
    return [
      // 如果 header 中 `x-add-header` 字段存在
      // 那就返回 `x-another-header` 标头
      {
        source: &#39;/:path*&#39;,
        has: [
          {
            type: &#39;header&#39;,
            key: &#39;x-add-header&#39;,
          },
        ],
        headers: [
          {
            key: &#39;x-another-header&#39;,
            value: &#39;hello&#39;,
          },
        ],
      },
      // 如果 header 中 `x-no-header` 字段不存在
      // 就返回 `x-another-header` 标头
      {
        source: &#39;/:path*&#39;,
        missing: [
          {
            type: &#39;header&#39;,
            key: &#39;x-no-header&#39;,
          },
        ],
        headers: [
          {
            key: &#39;x-another-header&#39;,
            value: &#39;hello&#39;,
          },
        ],
      },
      // 如果 source、query、cookie 都匹配
      // 就返回 `x-authorized` 标头
      {
        source: &#39;/specific/:path*&#39;,
        has: [
          {
            type: &#39;query&#39;,
            key: &#39;page&#39;,
            value: &#39;home&#39;,
          },
          {
            type: &#39;cookie&#39;,
            key: &#39;authorized&#39;,
            value: &#39;true&#39;,
          },
        ],
        headers: [
          {
            key: &#39;x-authorized&#39;,
            value: &#39;hello&#39;,
          },
        ],
      },
      //如果 header 中 `x-authorized` 存在且等于 yes 或 true
      // 就返回 `x-another-header` 标头
      {
        source: &#39;/:path*&#39;,
        has: [
          {
            type: &#39;header&#39;,
            key: &#39;x-authorized&#39;,
            value: &#39;(?&lt;authorized&gt;yes|true)&#39;,
          },
        ],
        headers: [
          {
            key: &#39;x-another-header&#39;,
            value: &#39;:authorized&#39;,
          },
        ],
      },
      // 如果 host 是 `example.com`,
      // 应用 header
      {
        source: &#39;/:path*&#39;,
        has: [
          {
            type: &#39;host&#39;,
            value: &#39;example.com&#39;,
          },
        ],
        headers: [
          {
            key: &#39;x-another-header&#39;,
            value: &#39;hello&#39;,
          },
        ],
      },
    ]
  },
}
</code></pre>
<p>注意，has 和 missing 判断的都是请求头中的值。 type 的四种类型为 header、cookie、host、query，其中下图中的值都是 header：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f286f2e743624f39b7f0ab7678bc7a10~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=544&s=121143&e=png&b=282828" alt="image.png"></p>
<p>cookie 指的是其中的 Cookie 标头，Next.js 已经自动做了解析，所以可以直接判断 Cookie 中的字段值：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0f0c3bde944941b01ece1cd01f43c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=544&s=118810&e=png&b=282828" alt="image (1).png"></p>
<p>host 就是主机名 + 端口，query 表示参数。以 <code>&#39;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&#39;</code>为例的话，<strong>host</strong> 的值为 <code>host.com:8080</code>。<strong>query</strong> 为 <code>query=string</code>。</p>
<h3>1.7. Cache-Control</h3>
<p>你不能在 <code>next.config.js</code> 中为页面或静态资源设置 <code>Cache-Control</code>标头，因为该标头会在生产中被覆盖，以确保有效缓存响应和静态资源。</p>
<h3>1.8. 选项</h3>
<h4>X-DNS-Prefetch-Control</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control">X-DNS-Prefetch-Control</a>  头控制着浏览器的 DNS 预读取功能。DNS 预读取是一项使浏览器主动去执行域名解析的功能，其范围包括文档的所有链接，无论是图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。</p>
<p>因为预读取会在后台执行，所以 DNS 很可能在链接对应的东西出现之前就已经解析完毕。这能够减少用户点击链接时的延迟。</p>
<pre><code class="language-json">{
  key: &#39;X-DNS-Prefetch-Control&#39;,
  value: &#39;on&#39;
}
</code></pre>
<h4>Strict-Transport-Security</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security">Strict-Transport-Security</a>（通常简称为 HSTS）响应标头用来通知浏览器应该只通过 HTTPS 访问该站点，并且以后使用 HTTP 访问该站点的所有尝试都应自动重定向到 HTTPS。</p>
<p>使用下面的配置，所有当前和未来的子域都将使用 <code>max-age</code> 为 2 年的 HTTPS：</p>
<pre><code class="language-javascript">{
  key: &#39;Strict-Transport-Security&#39;,
  value: &#39;max-age=63072000; includeSubDomains; preload&#39;
}
</code></pre>
<h4>X-Frame-Options</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options">X-Frame-Options</a> HTTP 响应头是用来给浏览器指示允许一个页面可否在 <code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免点击劫持 (en-US)攻击。</p>
<p>此标头已经被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors">frame-ancestors</a> 替代，它在现代浏览器中有更好的支持。</p>
<h4>Permissions-Policy</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Permissions-Policy">Permissions-Policy</a>  响应标头提供了一种可以在本页面或包含的 iframe 上启用或禁止浏览器特性的机制，之前叫做 <code>Feature-Policy</code>。</p>
<pre><code class="language-json">{
  key: &#39;Permissions-Policy&#39;,
  value: &#39;camera=(), microphone=(), geolocation=(), browsing-topics=()&#39;
}
</code></pre>
<h4>X-Content-Type-Options</h4>
<p>如果 <code>Content-Type</code> 标头没有被显示设置，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options">X-Content-Type-Options</a> 会阻止浏览器尝试猜测内容类型。这可以防止允许用户上传和共享文件的网站受到 XSS 攻击。</p>
<p>这个标头只有一个有效值是 <code>nosniff</code>。</p>
<pre><code class="language-json">{
  key: &#39;X-Content-Type-Options&#39;,
  value: &#39;nosniff&#39;
}
</code></pre>
<h4>Referrer-Policy</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy">Referrer-Policy</a> 控制当从当前网页导航到另一个网页时携带的信息内容：</p>
<pre><code class="language-json">{
  key: &#39;Referrer-Policy&#39;,
  value: &#39;origin-when-cross-origin&#39;
}
</code></pre>
<h2>2. redirects</h2>
<h3>2.1. 介绍</h3>
<p>重定向，顾名思义，将请求路径重定向到其他目标路径。配置重定向，使用 <code>next.config.js</code> 的 <code>redirects</code>，示例如下：</p>
<pre><code class="language-javascript">module.exports = {
  async redirects() {
    return [
      {
        source: &#39;/about&#39;,
        destination: &#39;/&#39;,
        permanent: true,
      },
    ]
  },
}
</code></pre>
<p><code>redirects</code> 是一个异步函数，该函数返回一个包含 <code>source</code>、<code>destination</code> 和 <code>permanent</code> 属性的对象数组，其中：</p>
<ul>
<li><code>source</code> 表示传入的请求路径</li>
<li><code>destination</code> 表示你重定向的的目标路径</li>
<li><code>permanent</code> 值为 true 或者  false。如果为 true，使用 308 状态码，表示客户端或搜索引擎永久缓存重定向。如果是 false，使用 307 状态码表示临时未缓存。</li>
</ul>
<p>为什么 Next.js 使用 307 和 308 呢？传统都是使用 302 表示临时重定向，301 表示永久重定向，但是很多浏览器会将重定向的请求方法修改为 GET，而不管原本的方法是什么。举个例子，如果浏览器发送了一个 POST 请求，<code>/v1/users</code> ，然后返回了 302 状态码，新地址是 <code>/v2/users</code>，则后续的请求会是 GET <code>/V2/users</code> 而不是 POST <code>/v2/users</code>，Next.js 用 307 临时重定向和 308 永久重定向状态码就是为了显示保留之前使用的请求方法。</p>
<p>除了这三个值外，还可以设置：</p>
<ul>
<li><code>basePath</code>：<code>false</code> 或者 <code>undefined</code>。当值为 <code>false</code> ，匹配时不会包含 <code>basePath</code>，只能用于外部重写</li>
<li><code>locale</code>：<code>false</code> 或者 <code>undefined</code>，匹配时是否应该包含 locale</li>
<li><code>has</code>：一个有 <code>type</code>、<code>key</code>、<code>value</code> 属性的对象数组</li>
<li><code>missing</code>：一个有 <code>type</code>、<code>key</code>、<code>value</code> 属性的对象数组</li>
</ul>
<p>重定向会在文件系统（包括页面和 <code>/public</code> 文件）之前被触发。</p>
<p>重定向不会应用于客户端路由（<code>Link</code>、<code>router.push</code>），除非使用了中间件，且有匹配的路径。</p>
<p>当应用重定向的时候，请求路径的参数也会传递给重定向目标路径。举个例子：</p>
<pre><code class="language-javascript">{
  source: &#39;/old-blog/:path*&#39;,
  destination: &#39;/blog/:path*&#39;,
  permanent: false
}
</code></pre>
<p>当请求<code>/old-blog/post-1?hello=world</code>时，客户端会重定向到 <code>/blog/post-1?hello=world</code>。</p>
<h3>2.2. source</h3>
<h4>路径匹配</h4>
<p>普通的路径匹配，举个例子，比如 <code>/old-blog/:slug</code>会匹配 <code>/old-blog/hello-world</code>（无嵌套路径，也就是说 <code>/old-blog/hello-world/about</code>不会匹配）</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: &#39;/old-blog/:slug&#39;,
        destination: &#39;/news/:slug&#39;,
        permanent: true,
      },
    ]
  },
}
</code></pre>
<h4>通配符路径匹配</h4>
<p>在参数后使用 <code>*</code> 实现通配符路径匹配，举个例子：<code>/blog/:slug*</code> 会匹配 <code>/blog/a/b/c/d/hello-world</code>：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: &#39;/blog/:slug*&#39;,
        destination: &#39;/news/:slug*&#39;,
        permanent: true,
      },
    ]
  },
}
</code></pre>
<h4>正则表达式路径匹配</h4>
<p>在参数后用括号将正则表达式括住实现正则表达式匹配，举个例子：<code>/post/:slug(\\d{1,})</code> 匹配 <code>/post/123</code> 而不匹配 <code>/post/abc</code></p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: &#39;/post/:slug(\\d{1,})&#39;,
        destination: &#39;/news/:slug&#39;,
        permanent: false,
      },
    ]
  },
}
</code></pre>
<p>注意：这 8 个字符  <code>(</code>、<code>)</code>、 <code>{</code>、 <code>}</code>、 <code>:</code>、 <code>*</code>、 <code>+</code>、 <code>?</code> 都会用于正则表达式匹配，所以需要用到这些字符本身的时候，使用 <code>\\</code>转义</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        // 匹配 `/english(default)/something`
        source: &#39;/english\\(default\\)/:slug&#39;,
        destination: &#39;/en-us/:slug&#39;,
        permanent: false,
      },
    ]
  },
}
</code></pre>
<h3>2.3. basePath</h3>
<p>当使用 <code>basePath</code> 的时候，每一个 <code>source</code> 和 <code>destination</code> 都会自动添加 <code>basePath</code> 作为前缀，除非你为重定向设置 <code>basePath: false</code>：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  basePath: &#39;/docs&#39;,
 
  async redirects() {
    return [
      {
        source: &#39;/with-basePath&#39;, // 自动变成 /docs/with-basePath
        destination: &#39;/another&#39;, // 自动变成 /docs/another
        permanent: false,
      },
      {
        // does not add /docs since basePath: false is set
        source: &#39;/without-basePath&#39;,
        destination: &#39;https://example.com&#39;,
        basePath: false,
        permanent: false,
      },
    ]
  },
}
</code></pre>
<h3>2.4. locale</h3>
<p>当使用 <code>i18n</code>的时候，每一个 <code>source</code> 和 <code>destination</code> 都会自动根据 <code>locales</code>添加前缀进行处理，除非你为重定向设置 <code>locale: false</code>。如果设置 <code>locale: false</code>，你必须使用一个 <code>locale</code> 作为 <code>source</code> 和 <code>destination</code> 的前缀才能够正确匹配，让我们看个例子：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  i18n: {
    locales: [&#39;en&#39;, &#39;fr&#39;, &#39;de&#39;],
    defaultLocale: &#39;en&#39;,
  },
 
  async redirects() {
    return [
      {
        // /with-locale -&gt; /another
        // /en/with-locale -&gt; /en/another
        // /fr/with-locale -&gt; /fr/another
        // /de/with-locale -&gt; /de/another
        source: &#39;/with-locale&#39;,
        destination: &#39;/another&#39;,
        permanent: false,
      },
      {
        // 因为 locale 设置为 false，所以不会自动处理
        // /nl/with-locale-manual -&gt; /nl/another
        source: &#39;/nl/with-locale-manual&#39;,
        destination: &#39;/nl/another&#39;,
        locale: false,
        permanent: false,
      },
      {
        // 因为 `en` 是 defaultLocale，所以匹配 &#39;/&#39;
        // /en -&gt; /en/another
        // / -&gt; /en/another
        source: &#39;/en&#39;,
        destination: &#39;/en/another&#39;,
        locale: false,
        permanent: false,
      },
      // 尽管 locale 设置为 false，但匹配所有 locale
      // /page -&gt; /en/newpage
      // /en/page -&gt; /en/newpage
      // /fr/page -&gt; /fr/newpage
      // /de/page -&gt; /de/newpage
      {
        source: &#39;/:locale/page&#39;,
        destination: &#39;/en/newpage&#39;,
        permanent: false,
        locale: false,
      },
      {
        // 转换为 /(en|fr|de)/(.*) 所以不会匹配 `/`
        // /page -&gt; /another2
        // /fr/page -&gt; /fr/another2
        // 匹配 `\` 或 `/fr` 使用 /:path*
        source: &#39;/(.*)&#39;,
        destination: &#39;/another2&#39;,
        permanent: false,
      },
    ]
  },
}
</code></pre>
<h3>2.5. has 和 missing</h3>
<p><code>has</code> 和 <code>missing</code> 是用来处理请求中的 header、cookie 和请求参数是否匹配某些字段，或者不匹配某些字段的时候，才发生重定向。</p>
<p>举个例子，比如请求 <code>/article?id=1&amp;author=yayu</code>，<code>has</code> 可以要求请求中必须有 id 参数，或者 id 参数等于 xxx 的时候才重定向。<code>missing</code> 可以要求请求中必须没有 id 参数，或者 id 参数不等于 xxx 的时候才重定向。</p>
<p><code>has</code> 和 <code>missing</code> 对象有下面这些字段：</p>
<ul>
<li><code>type</code>: <code>String</code>类型，值为 <code>header</code>、<code>cookie</code>、<code>host</code>、<code>query</code> 之一</li>
<li><code>key</code>: <code>String</code>类型，所选类型（也就是上面的四种值）中要匹配的 key</li>
<li><code>value</code>： <code>String</code> 或者 <code>undefined</code>，要检查的值。如果值为 <code>undefiend</code>，任何值都不会匹配。支持使用一个类似正则的字符串捕获值的特殊部分。比如 <code>first-(?&lt;paramName&gt;.*)</code>用于匹配 <code>first-second</code>，然后就可以用 <code>:paramName</code>获取 <code>second</code> 这个值</li>
</ul>
<p>其实跟 headers 是一样的，只不是过一个是返回标头，一个是发生重定向。</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async redirects() {
    return [
      // 如果 header `x-redirect-me` 存在,
      // 才应用重定向
      {
        source: &#39;/:path((?!another-page$).*)&#39;,
        has: [
          {
            type: &#39;header&#39;,
            key: &#39;x-redirect-me&#39;,
          },
        ],
        permanent: false,
        destination: &#39;/another-page&#39;,
      },
      // 如果 `x-dont-redirect` 存在,
      // 不会应用重定向
      {
        source: &#39;/:path((?!another-page$).*)&#39;,
        missing: [
          {
            type: &#39;header&#39;,
            key: &#39;x-do-not-redirect&#39;,
          },
        ],
        permanent: false,
        destination: &#39;/another-page&#39;,
      },
      // 如果 source, query, 和 cookie 匹配,
      // 会应用重定向
      {
        source: &#39;/specific/:path*&#39;,
        has: [
          {
            type: &#39;query&#39;,
            key: &#39;page&#39;,
            value: &#39;home&#39;,
          },
          {
            type: &#39;cookie&#39;,
            key: &#39;authorized&#39;,
            value: &#39;true&#39;,
          },
        ],
        permanent: false,
        destination: &#39;/another/:path*&#39;,
      },
      // 如果 header `x-authorized` 存在，并且是 yes huozhe true,
      // 会应用重定向
      {
        source: &#39;/&#39;,
        has: [
          {
            type: &#39;header&#39;,
            key: &#39;x-authorized&#39;,
            value: &#39;(?&lt;authorized&gt;yes|true)&#39;,
          },
        ],
        permanent: false,
        destination: &#39;/home?authorized=:authorized&#39;,
      },
      // 如果 host 是 `example.com`,
      // 会应用重定向
      {
        source: &#39;/:path((?!another-page$).*)&#39;,
        has: [
          {
            type: &#39;host&#39;,
            value: &#39;example.com&#39;,
          },
        ],
        permanent: false,
        destination: &#39;/another-page&#39;,
      },
    ]
  },
}
</code></pre>
<h2>3. rewrites</h2>
<h3>3.1. 介绍</h3>
<p>重写允许你将传入的请求路径映射到其他目标路径。它与重定向的不同之处在于，重写相当于扮演了 URL 代理的角色，会屏蔽目标路径，地址还是这个地址，但路由逻辑发生了变化。而重定向则是导航至新的页面，浏览器中的 URL 也会发生更改。配置重定向，使用 <code>next.config.js</code> 的 <code>rewrites</code>，示例如下：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: &#39;/about&#39;,
        destination: &#39;/&#39;,
      },
    ]
  },
}
</code></pre>
<p>重写会应用于客户端路由，在这个例子中，如果使用<code>&lt;Link href=&quot;/about&quot;&gt;</code> 会应用重写。</p>
<p><code>rewrites</code> 是一个异步函数，该函数可以返回一个包含 <code>source</code>、<code>destination</code> 属性的对象数组，其中：</p>
<ul>
<li><code>source</code> 表示传入的请求路径</li>
<li><code>destination</code> 表示你重写的的目标路径</li>
<li><code>basePath</code>：<code>false</code> 或者 <code>undefined</code>。当值为 <code>false</code> ，匹配时不会包含 <code>basePath</code>，只能用于外部重写</li>
<li><code>locale</code>：<code>false</code> 或者 <code>undefined</code>，匹配时是否应该包含 locale</li>
<li><code>has</code>：一个有 <code>type</code>、<code>key</code>、<code>value</code> 属性的对象数组</li>
<li><code>missing</code>：一个有 <code>type</code>、<code>key</code>、<code>value</code> 属性的对象数组</li>
</ul>
<p>如果返回的是这种数组，重写会在检查文件系统（页面和 /public 文件）之后和动态路由之前应用。</p>
<p>也可以返回一个具有特定属性的对象，这是为了实现更精细的控制，示例代码如下：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return {
      beforeFiles: [
        // 在 headers/redirects 之后
        // 在 _next/public files 文件之前触发
        {
          source: &#39;/some-page&#39;,
          destination: &#39;/somewhere-else&#39;,
          has: [{ type: &#39;query&#39;, key: &#39;overrideMe&#39; }],
        },
      ],
      afterFiles: [
        // 在 pages/public 之后，在动态路由之前触发
        {
          source: &#39;/non-existent&#39;,
          destination: &#39;/somewhere-else&#39;,
        },
      ],
      fallback: [
        // 在 pages/public files 和动态路由之后触发
        {
          source: &#39;/:path*&#39;,
          destination: `https://my-old-site.com/:path*`,
        },
      ],
    }
  },
}
</code></pre>
<p>这个时候就要说到 Next.js 的路由的检查顺序是：</p>
<ol>
<li>headers</li>
<li>redirects</li>
<li>beforeFiles 重写</li>
<li><code>public</code> 目录下的静态文件、<code>_next/static</code> 文件、非动态的页面</li>
<li>afterFiles 重写，如果每次匹配，</li>
<li>fallback 重写，会在渲染 404 页面之前和动态路由、所有静态资源检查前被引用</li>
</ol>
<h3>3.2. 重写参数</h3>
<p>如果 <code>destination</code>没有使用参数（例子中的<code>:path*</code>），那么 <code>source</code> 的中的参数会以查询字符串的形式（query）默认传递给 <code>destination</code>：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: &#39;/old-about/:path*&#39;,
        destination: &#39;/about&#39;,
      },
    ]
  },
}
</code></pre>
<p>假设 <code>app/about/page.js</code>的代码为：</p>
<pre><code class="language-javascript">// app/about/page.js
export default function Page(props) {
  console.dir(props)
  return  &lt;h1&gt;Hello About!&lt;/h1&gt;
}
</code></pre>
<p>访问 <code>/old-about/article?id=1</code>，打印的值为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf100c8b0fbc475b9a2472359b7e3190~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=900&h=36&s=49552&e=png&b=010509" alt="image.png"></p>
<p><code>source</code> 中的参数 article 可以在 searchParams 中查到。</p>
<p>如果 <code>destination</code>使用了参数，则不会自动传递任何参数：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: &#39;/docs/:path*&#39;,
        destination: &#39;/:path*&#39;,
      },
    ]
  },
}
</code></pre>
<p>访问 <code>/docs/about?id=1</code>，打印的值为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cef281c1d70417b9104f5ce57478ecd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=602&h=48&s=41058&e=png&b=010508" alt="image.png"></p>
<p>如果 <code>destination</code>使用了参数，你依然可以手动传递参数：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: &#39;/:first/:second&#39;,
        destination: &#39;/:first?second=:second&#39;
      },
    ]
  },
}
</code></pre>
<p>在这个例子中，因为 <code>destination</code> 使用了 <code>:first</code> 参数，所以 <code>:second</code> 参数不会自动被添加到 query 中，但我们可以通过例子中的方式手动添加，使得能够在 query 中获取。</p>
<p>访问 <code>/about/article?id=1</code>，打印的值为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fceaf76a61f403b81e8cf524e622c9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=888&h=44&s=56783&e=png&b=010508" alt="image.png"></p>
<h3>3.3. source</h3>
<h4>路径匹配</h4>
<p>普通的路径匹配，举个例子，比如 <code>/blog/:slug</code>会匹配 <code>/blog/hello-world</code>（无嵌套路径，也就是说 <code>/blog/hello-world/about</code>不会匹配）</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: &#39;/blog/:slug&#39;,
        destination: &#39;/news/:slug&#39;,
      },
    ]
  },
}
</code></pre>
<h4>通配符路径匹配</h4>
<p>在参数后使用 <code>*</code> 实现通配符路径匹配，举个例子：<code>/blog/:slug*</code> 会匹配 <code>/blog/a/b/c/d/hello-world</code>：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: &#39;/blog/:slug*&#39;,
        destination: &#39;/news/:slug*&#39;, // Matched parameters can be used in the destination
      },
    ]
  },
}
</code></pre>
<h4>3.3.3. 正则表达式路径匹配</h4>
<p>在参数后用括号将正则表达式括住实现正则表达式匹配，举个例子：<code>/post/:slug(\\d{1,})</code> 匹配 <code>/post/123</code> 而不匹配 <code>/post/abc</code></p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: &#39;/old-blog/:post(\\d{1,})&#39;,
        destination: &#39;/blog/:post&#39;,
      },
    ]
  },
}
</code></pre>
<p>注意：这 8 个字符  <code>(</code>、<code>)</code>、 <code>{</code>、 <code>}</code>、 <code>:</code>、 <code>*</code>、 <code>+</code>、 <code>?</code> 都会用于正则表达式匹配，所以需要用到这些字符本身的时候，使用 <code>\\</code>转义</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        // this will match `/english(default)/something` being requested
        source: &#39;/english\\(default\\)/:slug&#39;,
        destination: &#39;/en-us/:slug&#39;,
      },
    ]
  },
}
</code></pre>
<h3>3.4. basePath</h3>
<p>当使用 <code>basePath</code> 的时候，每一个 <code>source</code> 和 <code>destination</code> 都会自动添加 <code>basePath</code> 作为前缀，除非你为重写设置 <code>basePath: false</code>：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  basePath: &#39;/docs&#39;,
 
  async rewrites() {
    return [
      {
        source: &#39;/with-basePath&#39;, // 自动变成 /docs/with-basePath
        destination: &#39;/another&#39;, // 自动变成 /docs/another
      },
      {
        // 不会添加 /docs 到 /without-basePath 因为 basePath 设置为 false 
        source: &#39;/without-basePath&#39;,
        destination: &#39;https://example.com&#39;,
        basePath: false,
      },
    ]
  },
}
</code></pre>
<h3>3.5. locale</h3>
<p>当使用 <code>i18n</code>的时候，每一个 <code>source</code> 和 <code>destination</code> 都会自动根据 <code>locales</code>添加前缀进行处理，除非你为重写设置 <code>locale: false</code>。如果设置 <code>locale: false</code>，你必须使用一个 <code>locale</code> 作为 <code>source</code> 和 <code>destination</code> 的前缀才能够正确匹配，让我们看个例子：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  i18n: {
    locales: [&#39;en&#39;, &#39;fr&#39;, &#39;de&#39;],
    defaultLocale: &#39;en&#39;,
  },
 
  async rewrites() {
    return [
      {
        // /with-locale -&gt; /another
        // /en/with-locale -&gt; /en/another
        // /fr/with-locale -&gt; /fr/another
        // /de/with-locale -&gt; /de/another
        source: &#39;/with-locale&#39;,
        destination: &#39;/another&#39;,
      },
      {
        // 因为 locale 设置为 false，所以不会自动处理
        // /nl/with-locale-manual -&gt; /nl/another
        source: &#39;/nl/with-locale-manual&#39;,
        destination: &#39;/nl/another&#39;,
        locale: false,
      },
      {
        // 因为 `en` 是 defaultLocale，所以匹配 &#39;/&#39;
        // /en -&gt; /en/another
        // / -&gt; /en/another
        source: &#39;/en&#39;,
        destination: &#39;/en/another&#39;,
        locale: false
      },
      // 尽管 locale 设置为 false，但匹配所有 locale
      {
        source: &#39;/:locale/api-alias/:path*&#39;,
        destination: &#39;/api/:path*&#39;,
        locale: false,
      },
      {
        // 转换为 /(en|fr|de)/(.*) 所以不会匹配 `/`
        // /page -&gt; /another
        // /fr/page -&gt; /fr/another
        // 匹配 `\` 或 `/fr` 使用 /:path*
				source: &#39;/(.*)&#39;,
        destination: &#39;/another&#39;,
      },
    ]
  },
}
</code></pre>
<h3>3.6. has 和 missing</h3>
<p><code>has</code> 和 <code>missing</code> 是用来处理请求中的 header、cookie 和请求参数是否匹配某些字段，或者不匹配某些字段的时候，才发生重写。</p>
<p>举个例子，比如请求 <code>/article?id=1&amp;author=yayu</code>，<code>has</code> 可以要求请求中必须有 id 参数，或者 id 参数等于 xxx 的时候才重写。<code>missing</code> 可以要求请求中必须没有 id 参数，或者 id 参数不等于 xxx 的时候才重写。</p>
<p><code>has</code> 和 <code>missing</code> 对象有下面这些字段：</p>
<ul>
<li><code>type</code>: <code>String</code>类型，值为 <code>header</code>、<code>cookie</code>、<code>host</code>、<code>query</code> 之一</li>
<li><code>key</code>: <code>String</code>类型，所选类型（也就是上面的四种值）中要匹配的 key</li>
<li><code>value</code>： <code>String</code> 或者 <code>undefined</code>，要检查的值。如果值为 <code>undefiend</code>，任何值都不会匹配。支持使用一个类似正则的字符串捕获值的特殊部分。比如 <code>first-(?&lt;paramName&gt;.*)</code>用于匹配 <code>first-second</code>，然后就可以用 <code>:paramName</code>获取 <code>second</code> 这个值</li>
</ul>
<p>其实跟 redirects 是一样的，只不是过一个是重定向，一个是重写。</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      // 如果 header `x-rewrite-me` 存在,
      // 会应用重写
      {
        source: &#39;/:path*&#39;,
        has: [
          {
            type: &#39;header&#39;,
            key: &#39;x-rewrite-me&#39;,
          },
        ],
        destination: &#39;/another-page&#39;,
      },
      // 如果 `x-rewrite-me` 不存在
      // 会应用重写
      {
        source: &#39;/:path*&#39;,
        missing: [
          {
            type: &#39;header&#39;,
            key: &#39;x-rewrite-me&#39;,
          },
        ],
        destination: &#39;/another-page&#39;,
      },
      // 如果 source, query, 和 cookie 匹配,
      // 会应用重写
      {
        source: &#39;/specific/:path*&#39;,
        has: [
          {
            type: &#39;query&#39;,
            key: &#39;page&#39;,
            value: &#39;home&#39;,
          },
          {
            type: &#39;cookie&#39;,
            key: &#39;authorized&#39;,
            value: &#39;true&#39;,
          },
        ],
        destination: &#39;/:path*/home&#39;,
      },
      // 如果 header `x-authorized` 存在且为 yes 或 true
      // 会应用重写
      {
        source: &#39;/:path*&#39;,
        has: [
          {
            type: &#39;header&#39;,
            key: &#39;x-authorized&#39;,
            value: &#39;(?&lt;authorized&gt;yes|true)&#39;,
          },
        ],
        destination: &#39;/home?authorized=:authorized&#39;,
      },
      // 如果 host 是 `example.com`,
      // 会应用重写
      {
        source: &#39;/:path*&#39;,
        has: [
          {
            type: &#39;host&#39;,
            value: &#39;example.com&#39;,
          },
        ],
        destination: &#39;/another-page&#39;,
      },
    ]
  },
}
</code></pre>
<h3>3.7. 重写到外部 URL</h3>
<p>rewrites 可以重写到外部 url，这在增量采用 Next.js 的项目中特别有用，比如这个例子就是将应用中的 <code>/blog</code> 路由全部重写到外部网址：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: &#39;/blog&#39;,
        destination: &#39;https://example.com/blog&#39;,
      },
      {
        source: &#39;/blog/:slug&#39;,
        destination: &#39;https://example.com/blog/:slug&#39;,
      },
    ]
  },
}
</code></pre>
<p>如果设置了 <code>trailingSlash:true</code>，你也需要在 <code>source</code> 中插入一个尾部斜杠。如果目标地址也需要尾部斜杠，也应该包含在 <code>destination</code> 参数中。</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  trailingSlash: true,
  async rewrites() {
    return [
      {
        source: &#39;/blog/&#39;,
        destination: &#39;https://example.com/blog/&#39;,
      },
      {
        source: &#39;/blog/:path*/&#39;,
        destination: &#39;https://example.com/blog/:path*/&#39;,
      },
    ]
  },
}
</code></pre>
<h3>3.8. 增量采用 Next.js</h3>
<p>可以让 Next.js 在检查所有 Next.js 路由后，如果没有对应的路由，那就代理现有的网站。这样你将更多页面迁移成 Next.js 时，就无需重写配置：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  async rewrites() {
    return {
      fallback: [
        {
          source: &#39;/:path*&#39;,
          destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,
        },
      ],
    }
  },
}
</code></pre>
<h2>参考链接</h2>
<ol>
<li><a href="https://nextjs.org/docs/app/api-reference/next-config-js">https://nextjs.org/docs/app/api-reference/next-config-js</a></li>
<li><a href="https://nextjs.org/docs/app/api-reference/next-config-js/headers">https://nextjs.org/docs/app/api-reference/next-config-js/headers</a></li>
<li><a href="https://nextjs.org/docs/app/api-reference/next-config-js/redirects">https://nextjs.org/docs/app/api-reference/next-config-js/redirects</a></li>
<li><a href="https://nextjs.org/docs/app/api-reference/next-config-js/rewrites">https://nextjs.org/docs/app/api-reference/next-config-js/rewrites</a></li>
</ol>

</body>
</html>
  