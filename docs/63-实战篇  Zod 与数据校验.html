
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>63-实战篇  Zod 与数据校验</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>前面讲的 Clerk、Crowdin、Storybook 都可以不学，但 Zod 几乎是开发 Next.js 项目的必学内容，因为大部分的全栈项目都会有数据校验的场景。而 Next.js <a href="https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-validation-and-error-handling">官方文档</a>推荐的正是 <a href="https://zod.dev/">Zod</a>。</p>
<p>目前 Zod GitHub 31.5k Star，Npm 周均下载量 784W，几乎是前端做数据校验的第一选择。</p>
<p>本篇带大家快速上手 Zod。</p>
<h2>Zod 介绍</h2>
<h3>1. 基础介绍</h3>
<p>Zod 是一个 <strong>TypeScript 优先（TypeScript-first）<strong>的</strong>模式声明（schema declaration</strong>）和<strong>验证库（validation library）</strong>。</p>
<p>第一次听到这个介绍可能会“不明觉厉”，但其实很简单，举个简单的例子：</p>
<pre><code class="language-javascript">import { z } from &quot;zod&quot;;

// 模式声明
const schema = z.string();

// 数据校验
schema.parse(&quot;tuna&quot;); // =&gt; &quot;tuna&quot;
schema.parse(12); // =&gt; throws ZodError
</code></pre>
<p>这就是一个基本的模式声明和数据验证的例子。那什么是 TypeScript 优先呢？</p>
<p>简单来说，就是和 TypeScript 搭配使用，效果更佳。Zod 的目的在于消除重复的类型声明。使用 Zod，你只需声明一次验证器（validator），Zod 就会自动推断出静态 TypeScript 类型。细看 Zod 的 API，你会发现 Zod 与 TypeScript 的类型系统几乎是一对一的映射。</p>
<pre><code class="language-typescript">import { z } from &quot;zod&quot;;

// 模式声明
const User = z.object({
  username: z.string(),
});

// 数据校验
User.parse({ username: &quot;Ludwig&quot; });

// 提取推断类型
type User = z.infer&lt;typeof User&gt;;
// { username: string }
</code></pre>
<p>注意：但这并不是说使用 Zod 就一定要使用 TypeScript，Zod 也可用于纯 JavaScript。</p>
<h3>2. 运行时校验</h3>
<p>那你可能就好奇了，不都是数据校验，我都有 TypeScript 了，用 Zod 干嘛？</p>
<p>简单来说，TypeScript 是静态类型检查，但 Zod 不仅能在编译时提供类型检查，还能在运行时进行数据校验。这样就可以从源头上防止数据不合法而导致的错误，提高应用的稳定性。</p>
<p>举个例子，我们调用接口，获取返回的数据并进行处理：</p>
<pre><code class="language-javascript">export async function GET() {
  const res = await fetch(&quot;/api/product&quot;);
  const data = await res.json();

  const showPrice = data.price.toFixed(2);
  return Response.json({ showPrice });
}
</code></pre>
<p>在这段代码中，data 肯定会被推断为 any，因为 data 是运行时返回的数据，TypeScript 并不知道：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/995c4ad41b7a456f93a3ab60702ee5d4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1578&h=430&s=107232&e=png&b=1e1e1e" alt="image.png"></p>
<p>我们当然可以补全类型声明：</p>
<pre><code class="language-typescript">type Product = {
  price: number;
};

export async function GET() {
  const res = await fetch(&quot;/api/product&quot;);
  const data = await res.json() as Product;

  const showPrice = data.price.toFixed(2);
  return Response.json({ showPrice });
}
</code></pre>
<p>现在 price 字段声明了数字类型，如果我们使用了字符串的方法, TypeScript 就会报错。</p>
<p>但问题在于，即便我们不使用，但接口的返回数据类型突然改了呢？比如本来是 Number 类型，后端改为了 String 类型？因为 String 类型没有 toFixed 方法，那这段代码运行的时候就会报错。</p>
<p>为了防止运行时产生问题，我们还需要做判断，比如：</p>
<pre><code class="language-typescript">type Product = {
  price: number;
};

export async function GET() {
  const res = await fetch(&quot;/api/product&quot;);
  const data = await res.json() as Product;

  if (data &amp;&amp; data.price &amp;&amp; typeof data.price == &#39;number&#39;) {
    const showPrice = data.price.toFixed(2);
    return Response.json({ showPrice });
  } else {
    return Response.json({ success: false });
  }
}
</code></pre>
<p>如果涉及的字段众多，每个字段都写一段校验，代码很快就会变得臃肿难以维护。</p>
<p>而 Zod 正好可以解决这一问题，使用 Zod 后，代码改为：</p>
<pre><code class="language-javascript">import { z } from &#39;zod&#39;;

const schema = z.object({
    price: z.number()
});

export async function GET() {
  const res = await fetch(&quot;/api/product&quot;);
  const data = await res.json();

  const parsedData = schema.safeParse(data)
  
  if (parsedData.success) {
    const showPrice = parsedData.data.price.toFixed(2);
    return Response.json({ showPrice });
  } else {
    return Response.json({ success: false });
  }
}
</code></pre>
<p>整体代码更加简洁优雅，而且你也不需要再写类型声明：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100aa0e4055142aa92fc9aa1d83ff7dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1824&h=588&s=153334&e=png&b=1f1f1f" alt="image.png"></p>
<p>先对接口返回的数据进行校验，通过后再进行后续操作，从源头上防止数据不合法而导致的错误，提高应用的稳定性，而且还能帮助 TypeScript 进行推断，使用起来非常方便。</p>
<h3>3. 如何学习 Zod</h3>
<p>那具体如何学习 Zod 呢？就我个人看法，学习 Zod 的最好方法就是看 Zod 的官方文档：</p>
<ol>
<li>英文：<a href="https://zod.dev/">https://zod.dev/</a></li>
<li>中文：<a href="https://zod.dev/README_ZH">https://zod.dev/README_ZH</a></li>
</ol>
<p>内容并不算多， 20 分钟就可以看个大概。首要目的是了解 Zod 有哪些功能，具体要用的时候边查文档边学习。</p>
<p>如果文档看不下去，这是一个 30 分钟学习 Zod 的 <a href="https://www.youtube.com/watch?v=L6BE-U3oy80&ab_channel=WebDevSimplified">Youtube 视频</a>。</p>
<h2>Next.js + Zod</h2>
<p>具体 Zod 在 Next.js 中如何使用呢？我们先举个简单的使用示例。</p>
<h3>1. 纯后端数据校验</h3>
<p>运行 <code>npx create-next-app@latest</code>初始化项目。</p>
<p>修改 <code>app/page.js</code>，代码如下：</p>
<pre><code class="language-jsx">&#39;use client&#39;

import { validate } from &#39;./actions&#39;;
import { useFormState } from &#39;react-dom&#39;

export default function Page() {

  const [state, formAction] = useFormState(validate, {
    message: &#39;&#39;
  })

  return (
    &lt;section className=&quot;p-2&quot;&gt;
      &lt;form action={formAction} className=&quot;mb-2&quot;&gt;
        &lt;label htmlFor=&quot;name&quot; className=&quot;block text-sm font-medium leading-6 text-gray-900&quot;&gt;
          Name:
        &lt;/label&gt;
        &lt;input
          id=&quot;name&quot;
          name=&quot;name&quot;
          type=&quot;text&quot;
          required
          className=&quot;block w-full rounded-md border-0 p-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6 mb-2&quot;
          /&gt;
        &lt;button
          type=&quot;submit&quot;
          className=&quot;flex w-full justify-center rounded-md bg-indigo-600 px-3 py-1.5 text-sm font-semibold leading-6 text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600&quot;
          &gt;
          Login
        &lt;/button&gt;
      &lt;/form&gt;
      &lt;p aria-live=&quot;polite&quot;&gt;
        {state?.message}
      &lt;/p&gt;
    &lt;/section&gt;
  );
}
</code></pre>
<p>新建 <code>app/actions.js</code>，代码如下：</p>
<pre><code class="language-javascript">&#39;use server&#39;

import { z } from &quot;zod&quot;;

const schema = z.object({
  name: z.string({
    required_error: &quot;请输入昵称&quot;,
    invalid_type_error: &quot;昵称必须是字符串&quot;,
  }).min(2, { message: &quot;昵称最少需要 2 个字&quot; }).max(10, { message: &#39;昵称最多 10 个字&#39;})
});

export async function validate(prevState, formData) {

  const validatedFields = schema.safeParse({
    name: formData.get(&#39;name&#39;),
  })
 
  if (!validatedFields.success) {
    return {
      success: false,
      message: validatedFields.error.issues[0].message
    }
  }

  return {
    success: true,
    message: &#39;设置成功&#39;
  }
}
</code></pre>
<p>浏览器效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb50501a9d3a4d7dae8a0fd54ec5ddc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=790&h=389&s=81090&e=gif&f=52&b=fefefe" alt="17.gif"></p>
<h3>2. 前后端数据校验</h3>
<p>我们知道，在实际开发中，前后端数据校验都是必须的，前端校验是为了避免浪费后端资源，后端校验是因为不能相信来自客户端的数据。所以往往同样的校验，前后端都需要做一次。这就需要将 Schema 抽离出来，方便前后端使用。</p>
<p>新建 <code>app/todo/page.js</code>，代码如下：</p>
<pre><code class="language-jsx">import { findTodos } from &#39;./actions&#39;;
import Form from &#39;./form&#39;;

export default async function Page() {

  const todos = await findTodos()

  return (
    &lt;section className=&quot;p-2&quot;&gt;
      &lt;Form /&gt;
      &lt;ul&gt;
        {todos.map((todo) =&gt; {
      return &lt;li&gt;{todo}&lt;/li&gt;
    })}
      &lt;/ul&gt;
    &lt;/section&gt;
  );
}
</code></pre>
<p>这里我们将 Form 抽离为单独的组件，是因为 Form 需要使用客户端组件，本着尽可能减少客户端组件范围的原则，所以抽离成了单独的组件。</p>
<p>新建 <code>app/todo/form.js</code>，代码如下：</p>
<pre><code class="language-jsx">&#39;use client&#39;

import { useRef } from &#39;react&#39;;
import toast from &#39;react-hot-toast&#39;;
import { addTodo } from &#39;./actions&#39;;
import { TodoSchema } from &quot;./types&quot;;

export default function Form() {

  const formRef = useRef(null);

  const clientAction = async (formData) =&gt; {
    const submitTodo = {
      content: formData.get(&#39;todo&#39;)
    }

    // 客户端校验
    const result = TodoSchema.safeParse(submitTodo)
    if (!result.success) {
      toast.error(result.error.issues[0].message)
      return;
    }

    // 提交给服务端
    const response = await addTodo(result.data)
    if (response?.error) {
      toast.error(response.error)
      return;
    }

    formRef.current?.reset()
  }

  return (
    &lt;form action={clientAction} className=&quot;mb-2&quot; ref={formRef}&gt;
      &lt;label htmlFor=&quot;todo&quot; className=&quot;block text-sm font-medium leading-6 text-gray-900&quot;&gt;
        待办事项:
      &lt;/label&gt;
      &lt;input
        id=&quot;todo&quot;
        name=&quot;todo&quot;
        type=&quot;text&quot;
        required
        className=&quot;block w-full rounded-md border-0 p-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6 mb-2&quot;
        /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;flex w-full justify-center rounded-md bg-indigo-600 px-3 py-1.5 text-sm font-semibold leading-6 text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600&quot;
        &gt;
        添加
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>这段代码并不复杂，唯独要注意一点，那就是我们提交给服务端的数据，并不是我们自己构建的 <code>submitTodo</code>，而是校验后的 <code>result.data</code>，这是不一样的。举个例子：</p>
<pre><code class="language-javascript">// Schema 只定义了 content 字段
const TodoSchema = z.object({
  content: z.string()
})

// 校验的时候多提交了字段
const submitTodo = {
  content: formData.get(&#39;todo&#39;),
  other: &#39;111&#39;
}

// 数据校验成功
const result = TodoSchema.safeParse(submitTodo)
// 但 result.data 只会包含 content 字段
console.log(result.data) // -&gt; {content: &#39;123&#39;}
</code></pre>
<p>再举个例子：</p>
<pre><code class="language-javascript">// coerce 是为了进行强制转换原始类型
const TodoSchema = z.object({
  content: z.coerce.string()
})

// 数据是数字类型
const submitTodo = {
  content: 123
}

// 数据校验成功
const result = TodoSchema.safeParse(submitTodo)
// content 字段会转为字符串类型
console.log(result.data) // -&gt; {content: &#39;123&#39;}
</code></pre>
<p>简而言之，作为习惯，尽可能使用校验后的数据。</p>
<p>新建 <code>app/todo/actions.js</code>，代码如下：</p>
<pre><code class="language-javascript">&quot;use server&quot;

import { revalidatePath } from &quot;next/cache&quot;;
import { TodoSchema } from &quot;./types&quot;;

const todos = [];

export async function addTodo(todo) {

  // 服务端校验
  const result = TodoSchema.safeParse(todo)
 
  if (!result.success) {
    return {
      error: result.error.issues[0].message
    }
  }

  // 模拟数据库操作
  todos.push(result.data.content)

  revalidatePath(&quot;/todos&quot;)
}

export async function findTodos() {
  return todos
}
</code></pre>
<p>新建 <code>app/todo/types.ts</code>，代码如下：</p>
<pre><code class="language-typescript">import { z } from &#39;zod&#39;;

export const TodoSchema = z.object({
  content: z.string().trim().min(2, { message: &#39;最少需要输入 2 个字符&#39;}).max(10, { message: &#39;最多输入 10 个字符&#39;})
})

export type Todo = z.infer&lt;typeof TodoSchema&gt;
</code></pre>
<p>此时浏览器效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de12038a9f1e47d6b75893e164166a2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=790&h=389&s=175545&e=gif&f=84&b=fefefe" alt="18.gif">
注意：当数据为空进行提交的时候，走的是浏览器本身的非空校验，当数据不为空提交的时候，才是 Zod 的数据校验。</p>
<p>至此我们就完成了一个前后端校验的例子，当然这个例子还可以做的更完善一点，比如：</p>
<ol>
<li>将 actions.js、type.ts 抽离到单独的文件夹下，使用 alias 地址引入</li>
<li>使用 useFormStatus 添加按钮状态</li>
<li>使用 useOptimistic 实现<a href="https://juejin.cn/post/7347957960884355113">乐观更新</a></li>
</ol>

</body>
</html>
  