
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>56-实战篇  博客  性能分析</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>本篇讲解如何对 Next.js 应用的性能进行监控。</p>
<h2>Bundle Analyzer</h2>
<p>首先是 bundle 包的管理。Next.js 提供了 <code>@next/bundle-analyzer</code> 插件，它会生成每个模块大小及其依赖的可视化报告。你可以据此删除较大的依赖项或者拆分代码从而减少客户端 bundle 的大小。</p>
<p>安装插件：</p>
<pre><code class="language-bash">npm i @next/bundle-analyzer
</code></pre>
<p>修改 <code>next.config.mjs</code>，代码如下：</p>
<pre><code class="language-javascript">import { withContentlayer } from &#39;next-contentlayer&#39;
import bundleAnalyzer from &#39;@next/bundle-analyzer&#39;

const withBundleAnalyzer = bundleAnalyzer({
  enabled: process.env.ANALYZE === &#39;true&#39;,
})

export default withBundleAnalyzer(withContentlayer({}))
</code></pre>
<p>修改 <code>package.json</code>，添加脚本命令：</p>
<pre><code class="language-javascript">{
  // ...
  &quot;scripts&quot;: {
    &quot;analyze&quot;: &quot;ANALYZE=true next build&quot;
  },
  // ...
}
</code></pre>
<p>命令行运行 <code>npm run analyze</code>，它会陆续生成 3 个 HTML 文件，并同时为你打开浏览器展示文件：</p>
<p>一个是 <code>nodejs.html</code>，展示 nodejs server bundle：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb90f3432dc1455480378e321e78420c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3714&h=2064&s=1047462&e=png&b=f9f0ee" alt="截屏2024-05-15 22.10.32.png"></p>
<p>一个是 <code>edge.html</code>，展示 edge server bundle：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d533a4f5f198448fa4e5ba669ceb8f7e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3714&h=2064&s=712520&e=png&b=d07bb9" alt="截屏2024-05-15 22.11.22.png"></p>
<p>一个是 <code>client.html</code>，展示客户端浏览器 js bundle：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c8aec56784445709cd2b7724c635b1c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3714&h=2064&s=1231439&e=png&b=faf4f1" alt="截屏2024-05-15 22.11.57.png"></p>
<h2>性能测量</h2>
<p>如果你只是要在上线前，测一下应用的性能，看看有哪些性能优化工作要做，履行一下前端的“职责”，那你可以：</p>
<h3>1. Chrome Lighthouse 插件</h3>
<p>安装 <a href="https://chromewebstore.google.com/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk?hl=zh-cn">Chrome Lighthouse</a> 插件，安装完成后，开发者工具会有一个 lighthouse 选型，用于测量页面性能。以掘金为例：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f0a613f7edc42ffbfe850d856dc7a8a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3060&h=1476&s=769109&e=png&b=242424" alt="image.png"></p>
<p>lighthouse 会列出需要具体改善的点，参照建议完善即可。</p>
<h3>2. PageSpeed Insights</h3>
<p>PageSpeed Insights 是一款由 Google 开发的网页性能评估工具，可以帮助开发者评估网页的性能，并提供优化建议。</p>
<p>打开 <a href="https://pagespeed.web.dev/">https://pagespeed.web.dev/</a>，输入网址查看页面测试结果即可：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ac4248fb494d69a3150441612e48eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2552&h=2166&s=713157&e=png&b=ffffff" alt="image.png"></p>
<h3>3. 其他性能测试网站</h3>
<p>当然这种性能测试网站还是蛮多的，比如 <a href="https://www.webpagetest.org/">https://www.webpagetest.org/</a>、<a href="https://tools.pingdom.com/">https://tools.pingdom.com/</a> 等等</p>
<h2>Web Vitals Analytics</h2>
<p>但是这种上线前测试一下性能的做法问题也很明显，样本有限导致数据不够准确，而且无法准确反应真实用户的体验。</p>
<p>如果真的要解决这个问题的话，就需要在页面实现测量和上报性能相关的数据。可是要测量哪些性能相关的数据呢？性能相关的数据又该如何上报、搜集、分析、输出图标呢？</p>
<p>这里的解决方案有很多种，我提供一种 Prometheus + Grafana 的方式，这套技术选型也是常见的用于数据采集、分析的解决方案。我们且慢慢说来。</p>
<h3>1. 性能测量</h3>
<p>其实 Next.js 支持对性能进行测量和上报。Next.js 提供了 <code>useReportWebVitals</code> hook 自行管理数据。</p>
<p>新建 <code>components/WebVitals.js</code>，代码如下：</p>
<pre><code class="language-javascript">&#39;use client&#39;
 
import { useReportWebVitals } from &#39;next/web-vitals&#39;
 
export function WebVitals() {
  useReportWebVitals((metric) =&gt; {
    console.log(metric)
  })
}
</code></pre>
<p>修改 <code>next-blog/app/[lng]/layout.js</code>，添加代码如下：</p>
<pre><code class="language-jsx">// ...
import { WebVitals } from &#39;@/components/WebVitals.js&#39;
// ...

export default function RootLayout({ children, params: { lng } }) {
  return (
    &lt;html lang={lng} dir={dir(lng)} suppressHydrationWarning&gt;
      &lt;body&gt;
        &lt;WebVitals /&gt;
        &lt;ThemeProviders&gt;
          &lt;header className=&quot;flex justify-end&quot;&gt;
            &lt;ThemeSwitch /&gt;
            &lt;LangSwitch /&gt;
          &lt;/header&gt;
          {children}
        &lt;/ThemeProviders&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<p>访问页面如 <a href="http://localhost:3000/posts/first">http://localhost:3000/posts/first</a>，打印效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8749a5476f043fe86c08394d69040df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3460&h=920&s=369331&e=png&b=2a2a2a" alt="image.png"></p>
<p>这 6 个指标就是 Web Vitals（网页指标），它是 Google 的一项计划，旨在针对网页质量信号提供统一指南，这些信号对于提供出色的网页用户体验至关重要。它的目标是简化各种可用的性能测量工具，并帮助网站所有者专注于最重要的指标。</p>
<p>注：其实业界尝试过非常多用于衡量性能和体验的指标，但很多指标由于难以测量、逻辑复杂等原因逐渐消亡。Web Vitals 背靠 Google，算是大浪淘沙，经过时间的检验。但这些指标也会随着时间的推移而演变，目前是这 6 个指标。</p>
<p>为了更直观的展示这些指标，我为大家总结了一个表格：</p>
<table>
<thead>
<tr>
<th></th>
<th>指标</th>
<th>中文名</th>
<th>目的</th>
<th>标准</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>LCP（Largest Contentful Paint）</td>
<td>最大内容绘制</td>
<td>衡量加载性能</td>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d1dfcf271646e3b21e327c02f96d28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1056&h=304&s=35810&e=png&b=ffffff" alt="image.png"></td>
</tr>
<tr>
<td>Core Web Vitals <br/>这组指标侧重于用户体验的三个方面：加载、互动和视觉稳定性</td>
<td>INP（Interaction to Next Paint）</td>
<td>交互到绘制延迟</td>
<td>衡量互动</td>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/909e25d7feb544a4a3726c2848307d75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034&h=320&s=35983&e=png&b=ffffff" alt="image.png"></td>
</tr>
<tr>
<td></td>
<td>CLS（Cumulative Layout Shift)</td>
<td>累积布局偏移</td>
<td>衡量视觉稳定性</td>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b57ac84784f84123b0aa14b00d2d7b01~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1084&h=322&s=34385&e=png&b=ffffff" alt="image.png"></td>
</tr>
<tr>
<td></td>
<td>FCP（First Contentful Paint）</td>
<td>首次内容绘制</td>
<td>衡量加载体验，有助于诊断 LCP 问题（服务器响应时间过长或阻塞渲染的资源）</td>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4eca092a85f41bbb5262d0ee5dafa3d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072&h=324&s=37089&e=png&b=ffffff" alt="image.png"></td>
</tr>
<tr>
<td>Core Web Vitals 的代理或补充指标 <br/>这组指标有助于捕获更广泛的体验或诊断特定问题</td>
<td>FID（First Input Delay）</td>
<td>首次输入延迟</td>
<td>衡量互动，未来可能完全被 INP 替代</td>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a9aba8aa6984a308062c3814181cb21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1054&h=318&s=37141&e=png&b=ffffff" alt="image.png"></td>
</tr>
<tr>
<td></td>
<td>TTFB（Time to First Byte）</td>
<td>第一字节时间</td>
<td>衡量加载体验，有助于诊断 LCP 问题</td>
<td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee6068b7946a4b0380ef770fc7ea7a6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1052&h=326&s=37460&e=png&b=ffffff" alt="image.png"></td>
</tr>
</tbody></table>
<p>那如何测量这些指标呢？</p>
<p>Chrome 团队提供了 <a href="https://github.com/GoogleChrome/web-vitals">web-vitals</a> 开源工具库，它基于统一的浏览器 Performance API 获取标准化的用户体验数据。</p>
<p>Next.js 提供的 useReportWebVitals hook 背后也是用这个库来实现的。</p>
<h3>2. 性能上报</h3>
<h4>1.1. Prometheus 介绍</h4>
<p>采集到了数据，数据该如何上报并可视化呢？</p>
<p>我们的技术方案是用 Prometheus 和 Grafana。我们先来介绍一下这两个技术选型：</p>
<p><a href="https://prometheus.io/">Prometheus</a>（普罗米修斯）是一个用于监控和报警的开源系统，它自带一个基于时间序列的数据库。</p>
<p>它的架构设计如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/863b7c9e123149bfbd5a50d36683455f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1351&h=811&s=326973&e=png&b=fdfcfc" alt="image.png"></p>
<p>看到这个架构图先不要害怕，其实很简单。简单来说，Prometheus 由这几部分组成：</p>
<ol>
<li>Prometheus Server 负责收集数据，将数据存放到数据库中</li>
<li>数据怎么发给 Prometheus Server 呢？有两种方式上报数据：<ol>
<li>一种是 pull 模式，待监控的服务暴露指标接口，由 Prometheus server 定期拉取采集。</li>
<li>另一种是 push 模式，待监控的服务直接将数据推给  Prometheus server（通常会借助 Pushgateway 待监控服务推给 Pushgateway，Prometheus Server pull Pushgateway）</li>
</ol>
</li>
<li>Alertmanager 负责监控指标进行报警，使用 email 等方式通知</li>
<li>PromQL（Prometheus Query Language）是 Prometheus 内置的数据查询语言，可以结合 Grafana 等数据可视化工具将数据更好的展现出来</li>
</ol>
<p>关于本篇我们采用的方式：</p>
<p>我们会使用 Express 自建一个服务，用于处理 Next.js Web Vitals 数据的上报。然后由 Prometheus Server 定期拉取指标数据，最后结合 Grafana 做数据可视化。</p>
<h4>1.2. Grafana 介绍</h4>
<p><a href="https://grafana.com/">Grafana</a> 是一款开源的数据可视化工具，使用它是因为：</p>
<ol>
<li>与 Prometheus 兼容良好</li>
<li>可视化模板多，界面高大上</li>
<li>可免费私有部署</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b7c43fb8c94d2f9bd757ee90b88585~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3000&h=2140&s=786614&e=png&b=191b1f" alt="image.png"></p>
<h4>1.3. Express Server</h4>
<p>让我们运行：</p>
<pre><code class="language-bash"># 创建文件夹
mkdir node-monitor &amp;&amp; cd node-monitor
# 初始化
npm init
# 安装依赖项，其中 prom-client 是 Prometheus 的 Node 客户端
npm i express cors prom-client
</code></pre>
<p>新建 <code>app.js</code>，代码如下：</p>
<pre><code class="language-javascript">import express from &#39;express&#39;;
import client, { collectDefaultMetrics } from &#39;prom-client&#39;;
import cors from &#39;cors&#39;;

const register = new client.Registry();
collectDefaultMetrics({ register });

const app = express();

app.use(express.text())
app.use(cors())

app.get(&#39;/metrics&#39;, async (_req, res) =&gt; {
  try {
    res.set(&#39;Content-Type&#39;, register.contentType);
    res.end(await register.metrics());
  } catch (err) {
    res.status(500).end(err);
  }
});

app.post(&#39;/report&#39;, function (req, res) {
  const { name, rating} = JSON.parse(req.body);
  let counter = register.getSingleMetric(name);
  if (!counter) {
    counter = new client.Counter({
      name,
      help: req.body,
      registers: [register],
      labelNames: [&#39;rating&#39;],
    });
  }
  counter.inc({
    rating
  }, 1);
  res.status(200).json({ success: true });
});

app.listen(4001, &#39;0.0.0.0&#39;);
</code></pre>
<p>在这段代码中，我们提供了一个 <code>/metrics</code>接口用于 Prometheus Server 拉取数据，一个 <code>/report</code>接口用于 Next.js 应用上报数据。至于代码具体为什么这样写，参考 <a href="https://github.com/siimon/prom-client">prom-client</a>。</p>
<p>修改 <code>package.json</code>，添加代码如下：</p>
<pre><code class="language-javascript">{
  // ...
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node app.js&quot;
  },
  // ...
}
</code></pre>
<p>运行 <code>npm start</code>，打开 <a href="http://localhost:4001/metrics">http://localhost:4001/metrics</a>，效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46686888379642eb87c1e13a13270ce7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2598&h=900&s=287397&e=png&b=181818" alt="image.png"></p>
<p>数据看不懂？没有关系，这些是 Node 应用相关的数据，可用于监控 Node 性能。我们真正要监控和记录的是 Web Vitals 相关的数据。</p>
<p>修改我们的 Next.js 应用 <code>components/WebVitals.js</code>：完整代码如下：</p>
<pre><code class="language-javascript">&#39;use client&#39;
 
import { useReportWebVitals } from &#39;next/web-vitals&#39;
 
export function WebVitals() {
  useReportWebVitals((metric) =&gt; {
    console.log(metric)

    const body = JSON.stringify(metric)
    const url = &#39;http://localhost:4001/report&#39;
   
    // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
    if (navigator.sendBeacon) {
      navigator.sendBeacon(url, body)
    } else {
      fetch(url, { body, method: &#39;POST&#39;, keepalive: true })
    }
    
  })
}
</code></pre>
<p>关于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon">navigator.sendBeacon</a>：</p>
<blockquote>
<p>navigator.sendBeacon() 方法可用于通过 HTTP POST 将少量数据 异步 传输到 Web 服务器。
它主要用于将统计数据发送到 Web 服务器，同时避免了用传统技术（如：XMLHttpRequest）发送分析数据的一些问题。</p>
</blockquote>
<p>我们刷新一下 Next.js 的页面，上报一些数据，再查看 <a href="http://localhost:4001/metrics">http://localhost:4001/metrics</a>，可以看到产生了一批 Web Vitals 相关的数据指标：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0b38930a07b4b85b52dc61de06b4854~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2902&h=800&s=281058&e=png&b=161616" alt="image.png"></p>
<p>这说明我们的 Next.js 应用（3000 端口）和 Express 应用（4001 端口）已经打通了！</p>
<h4>1.4. Docker</h4>
<p>为了方便起见，我们使用 Docker 来开启 Prometheus 和 Grafana。</p>
<p>在 node-monitor 项目下新建 <code>prometheus.yml</code>文件（当然放在其他地方也是可以的），用于 Prometheus 的配置文件，代码如下：</p>
<pre><code class="language-javascript">global:
  scrape_interval: 5s
scrape_configs:
  - job_name: &quot;next-app&quot;
    static_configs:
      - targets: [&quot;docker.for.mac.host.internal:4001&quot;]
</code></pre>
<p>配置文件告诉 Prometheus 每 5 秒抓取一次所有目标。目标在 scrape_configs 下定义。在 Mac 上，需要使用 <code>docker.for.mac.host.internal</code> 作为主机，以便 Prometheus Docker 容器可以抓取本地 Node.js HTTP 服务器的指标。在 Windows 上，使用 <code>docker.for.win.localhost</code>；在 Linux 上，使用 <code>localhost</code>。</p>
<p>然后运行：</p>
<pre><code class="language-javascript">docker run --rm -p 9090:9090 \
  -v `pwd`/prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus
</code></pre>
<p>Windows 用户需要将 pwd 替换为当前工作目录的路径。</p>
<p>注：这里我们将端口开发了默认的 9090 端口，如果你开了 Clash，可能会产生端口冲突。关掉 Clash 或者修改 Clash 的配置文件，将其更改到其他端口。</p>
<p>如果正常开启，此时访问 <a href="http://localhost:9090/">http://localhost:9090/</a>，可以看到：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe0831a7970e4ec5830011c4bb4931f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3498&h=1052&s=258440&e=png&b=212428" alt="image.png"></p>
<p>对于 Prometheus 的初学者，可以通过访问 <a href="http://localhost:9090/api/v1/label/__name__/values">http://localhost:9090/api/v1/label/<strong>name</strong>/values</a> 来查看有哪些数据指标：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3ea7aa99fe64828b0e8a34d7488585a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1936&h=1130&s=228595&e=png&b=171717" alt="image.png"></p>
<p>我们输入 <code>FCP</code>，点击 <code>Execute</code> 按钮，如果能查询到数据就说明 Prometheus 应用（开在 9090 端口）与我们的 Express 应用（开在 4001 端口）连接成功：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e63b6252d104088b8cb2472b55890c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3490&h=1312&s=341096&e=png&b=1f2226" alt="image.png"></p>
<p>接下来开启 Grafana，运行：</p>
<pre><code class="language-javascript">docker run -d --name=grafana -p 3001:3000 grafana/grafana
</code></pre>
<p>正常 Grafana 开启在 3000 端口，但跟我们的 Next.js 应用冲突了，所以开在了 3001 端口。如果正常开启，访问 <a href="http://localhost:3001/">http://localhost:3001/</a>，会跳转到登录页面：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4899f6fdea85494b9cda549f88f0bca1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2558&h=1210&s=1700983&e=png&b=2b2537" alt="image.png"></p>
<p>账号和密码都是 admin，登录后：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d34334c8d4ea4555a69fc7099870a148~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3480&h=1416&s=342156&e=png&b=1b1d21" alt="截屏2024-05-17 22.19.56.png"></p>
<p>选择 <code>Prometheus</code>，然后点击 <code>Add new data source</code>按钮，添加 Prometheus 作为数据源，进入设置页面：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd2607eefdc340e2898d399d70de7b91~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3664&h=1450&s=354870&e=png&b=1a1c20" alt="截屏2024-05-17 22.22.13.png"></p>
<p>Prometheus server URL 这里填写 <a href="http://host.docker.internal:9090">http://host.docker.internal:9090</a>，这是因为 Prometheus 和 Grafana 都是通过 Docker 开启，环境与本机有隔离，所以无法通过 localhost 直接访问。如果这个地址不行，填写 <code>http://prometheus:9090</code> 试试。</p>
<p>如果能够配置成功，此时我们的各个应用就算联调成功了。一共涉及 4 个应用，Next.js 应用是我们开发的博客项目，博客页面会上报 Web Vitals 数据，Express 应用会接收上报的 Web Vitals，并提供 /metrics 接口供 Prometheus 应用拉取采集数据。最后 Grafana 应用会连接 Prometheus，用可视化的图表代替 Prometheus 的 PromQL 语句查询。</p>
<h4>1.5. Grafana 图表</h4>
<p>接下来我们开始建立一个 Grafana 图表：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bf87963ff744bc795efe7c595db3deb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3678&h=1280&s=347729&e=png&b=1b1d21" alt="截屏2024-05-17 22.30.38.png">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31acbd4b306c4ac1afa605e17d45400f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3668&h=1736&s=442489&e=png&b=14151a" alt="截屏2024-05-17 22.31.46.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d091b837d1e34f5c96f1cb31f9cc7d6a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3678&h=1618&s=555754&e=png&b=1d1f23" alt="截屏2024-05-17 22.32.21.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77875e5d8e7b4b0397d0fcdaaa7b75c2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3784&h=2050&s=814347&e=png&b=1a1c20" alt="截屏2024-05-17 22.34.37.png"></p>
<p>这样我们就建立了一个 FCP 评分占比的饼图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee3b961b8f6f476294e32d18c588891d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3278&h=1368&s=423560&e=png&b=1b1d21" alt="image.png"></p>
<p>可以看到评分为 poor 的有多少个，评分为 good 的有多少个。（数据量太少了，所以没有 need improvement)</p>
<p>接下来我们就可以根据自己的需要自定义需要的图表。</p>
<h2>最后</h2>
<p>目前整体的打通非常简陋，比如 Prometheus 和 Grafana 都没有做数据持久化，一旦重启，数据就会丢失。只监控了自定义的 Web Vitals 指标，Node 性能相关的指标没有做自定义上报。Grafana 也只实现了简单的百分比，而没有实现各种高大上的图表。</p>
<p>Prometheus 和 Grafana 其实内容非常多，碍于作者能力有限，只能为大家简单介绍下这套技术方案，更多的内容还需要大家自己去探索。</p>
<h2>参考链接</h2>
<ol>
<li><a href="https://web.dev/articles/vitals?hl=zh-cn">https://web.dev/articles/vitals?hl=zh-cn</a></li>
<li><a href="https://web.dev/articles/fcp?hl=en">https://web.dev/articles/fcp?hl=en</a></li>
<li><a href="https://codersociety.com/blog/articles/nodejs-application-monitoring-with-prometheus-and-grafana">https://codersociety.com/blog/articles/nodejs-application-monitoring-with-prometheus-and-grafana</a></li>
<li><a href="https://brew.sh/">https://brew.sh/</a></li>
<li><a href="https://github.com/vercel/next.js/discussions/16205">https://github.com/vercel/next.js/discussions/16205</a></li>
<li><a href="https://hub.docker.com/r/prom/prometheus">https://hub.docker.com/r/prom/prometheus</a></li>
<li><a href="https://github.com/grafana/grafana/issues/46434">https://github.com/grafana/grafana/issues/46434</a></li>
</ol>

</body>
</html>
  