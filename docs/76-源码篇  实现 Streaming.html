
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>76-源码篇  实现 Streaming</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>在<a href="https://juejin.cn/book/7307859898316881957/section/7309115864737611827">《 源码篇 | RSC 实现原理》</a>中，我们优化了 React RSC 的实现，最终的效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d98817c58b744efa83bd9da9dc28d2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606&h=1015&s=325073&e=gif&f=77&b=fafafa" alt="react-rsc-12.gif"></p>
<p>导航的时候，其实获取的是目标页面的 JSX 对象，但在 Next.js 中，返回的其实是针对流进行过优化的特殊格式，我们称之为 RSC Payload，效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da1954ff6701460d97d007212800bb2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4366&h=1432&s=619356&e=png&b=fcfbfb" alt="截屏2024-04-16 15.49.37.png"></p>
<p>此外 Next.js 也支持 <code>&lt;Suspense&gt;</code> 组件：</p>
<pre><code class="language-jsx">import { Suspense } from &#39;react&#39;

const sleep = ms =&gt; new Promise(r =&gt; setTimeout(r, ms));

async function PostFeed() {
  await sleep(2000)
  return &lt;h1&gt;Hello PostFeed&lt;/h1&gt;
}

export default function Dashboard() {
  return (
    &lt;section&gt;
      &lt;Suspense fallback={&lt;p&gt;Loading PostFeed Component&lt;/p&gt;}&gt;
        &lt;PostFeed /&gt;
      &lt;/Suspense&gt;
    &lt;/section&gt;
  )
}
</code></pre>
<p>但目前我们的实现并不支持 Suspense 组件，因为我们使用自定义的 renderJSXToClientJSX 获取页面 JSX 对象时，并不支持识别 Suspense 组件。</p>
<p>本篇我们会在<a href="https://juejin.cn/book/7307859898316881957/section/7309115864737611827">《 源码篇 | RSC 实现原理》</a>的实现基础上，实现 Streaming 并且支持 <code>&lt;Suspense&gt;</code> 组件。如果没有实现之前的代码，可以运行：</p>
<pre><code class="language-javascript"># 下载指定分支的代码
git clone -b react-rsc-9 git@github.com:mqyqingfeng/next-app-demo.git
# 进入目录并安装依赖项
cd next-app-demo &amp;&amp; npm i
# 启动
npm start
</code></pre>
<h2>实现思路</h2>
<p>该如何实现 Streaming 效果呢？</p>
<p>其实 React 提供了 <a href="https://www.npmjs.com/package/react-server-dom-webpack?activeTab=readme">react-server-dom-webpack</a> 用于处理 RSC，尽管它现在都没有正式的介绍，查看 <a href="https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack">GitHub 仓库</a>，也只有简短的说明：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b4d50859ee445f86834a027f397ce1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1866&h=376&s=63394&e=png&b=ffffff" alt="image.png"></p>
<p>其中 Flight 是 RSC 的代号，简单来说，就是该功能还在实验中，使用 Webpack 用于 RSC DOM 绑定，可以自己玩着玩，但不能用于生产……</p>
<p>虽然介绍很少，但在 <a href="https://github.com/facebook/react/blob/734956ace6450bc0c95d8d749dee74f4a140597b/fixtures/flight/src/index.js#L4">React Flight</a> 以及 <a href="https://github.com/reactjs/server-components-demo/blob/main/server/api.server.js">server-components-demo</a> 都可以看到它的身影。而我们今天的实现也要用到 react-server-dom-webpack，所以我们先介绍一下它的基本用法（以下都是我摸索出来的，最终用法还尚未确定）。</p>
<p>当在服务端使用的时候：</p>
<pre><code class="language-javascript">import { renderToPipeableStream } from &quot;react-server-dom-webpack/server.node&quot;

app.get(&quot;/&quot;, async (req, res) =&gt; {
  const { pipe } = renderToPipeableStream(&lt;App /&gt;);
  pipe(res);
});
</code></pre>
<p>它会将组件渲染成下图这种流格式：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c15cb01077e4403ab166d6ffec04a86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3858&h=868&s=426399&e=png&b=fefefe" alt="image.png"></p>
<p>而在客户端使用的时候，如果是在浏览器环境：</p>
<pre><code class="language-javascript">import { createFromFetch } from &quot;react-server-dom-webpack/client&quot;

let data = createFromFetch(
  fetch(currentPathname + &#39;?jsx&#39;)
)
</code></pre>
<p>data 是一个包含页面 JSX 对象的 Promise，你可以这样读取其中的值：</p>
<pre><code class="language-javascript">data.then((jsx) =&gt; {
  hydrateRoot(document, jsx)
})
</code></pre>
<p>但为了优雅一点，可以结合 React 的 <a href="https://react.dev/reference/react/use#">use hook</a> 来使用：</p>
<pre><code class="language-javascript">function Shell({ data }) {
  const [root, setRoot] = useState(use(data))
  return root
}

hydrateRoot(document, React.createElement(Shell, { data }))
</code></pre>
<p>这里我们构建了一个空壳 Shell 组件，并将 JSX 对象设置为状态，这样当调用 setRoot 的时候，页面内容就会更新。</p>
<p>如果是在 Node 环境（就比如 SSR Server）：</p>
<pre><code class="language-javascript">import { createFromNodeStream } from &quot;react-server-dom-webpack/client&quot;

const root = await createFromNodeStream(stream, {})
</code></pre>
<p>root 最终是页面的 JSX 对象。因为是流，可以结合 react-dom/server 的 <a href="https://react.dev/reference/react-dom/server/renderToPipeableStream">renderToPipeableStream</a> 来使用：</p>
<pre><code class="language-javascript">app.get(&quot;/&quot;, async (req, res) =&gt; {
  const { pipe } = renderToPipeableStream(root)
  pipe(res)
});
</code></pre>
<p>让我们再回顾下之前的实现方案：</p>
<p>页面首次加载时，RSC Server 负责生成页面的 JSX 对象，SSR Server 负责生成 HTML，页面 client.js 调用 <code>hydrateRoot(document, getInitialClientJSX())</code>水合页面。在后续导航时，获取目标页面的 JSX 对象，调用 <code>root.render(clientJSX)</code> 进行更新。</p>
<p>但是鉴于 react-server-dom-webpack 的特殊使用方式，新的实现方案为：</p>
<p>页面首次加载时，RSC Server 负责生成页面的 RSC Payload，SSR Server 负责生成 HTML，页面 client.js 调用<code>createFromFetch()</code>获取页面 JSX 对象，调用 <code>hydrateRoot(document, jsx)</code>水合页面。在后续导航时，依然用 createFromFetch 获取目标页面 JSX 对象，借助空壳 Shell 组件的更新状态函数，实现页面更新。</p>
<p>其核心代码实现是：</p>
<pre><code class="language-javascript">// fetch 返回的是页面的 RSC Payload，createFromFetch 返回的是包含页面 JSX 对象的 Promise
let data = createFromFetch(fetch(currentPathname + &#39;?jsx&#39;))

let updateRoot

function Shell({ data }) {
  // 使用 use(data) 读取页面 JSX 对象
  const [root, setRoot] = useState(use(data))
  updateRoot = setRoot
  return root
}

// 首次加载的时候使用页面的 JSX 对象水合页面
hydrateRoot(document, React.createElement(Shell, { data }))

// 后续导航时更新状态
async function navigate(pathname) {
  const root = await createFromFetch(fetch(pathname + &#39;?jsx&#39;))
  updateRoot(root)
}
</code></pre>
<p>如果你还不理解，没有关系，我们边写边理解吧！</p>
<h2>Step1：实现 RSC Payload</h2>
<p>首先安装依赖，为了保持与 React、React DOM 与 react-server-dom-webpack 版本一致，我们统一使用 <code>18.3.0-canary-c3048aab4-20240326</code> 这个版本：</p>
<pre><code class="language-javascript">npm i react@18.3.0-canary-c3048aab4-20240326 react-dom@18.3.0-canary-c3048aab4-20240326 react-server-dom-webpack@18.3.0-canary-c3048aab4-20240326
</code></pre>
<p>注：为什么使用这个版本呢？翻看 react-server-dom-webpack npm 的<a href="https://www.npmjs.com/package/react-server-dom-webpack?activeTab=versions">版本记录</a>，这是 18.3.0 版本最新的一版。下一版本就是 19.0.0 了，鉴于 React 的最新版本才 18.2.0，我们继续使用 v18。</p>
<p>修改 <code>generator.tsx</code>，代码如下：</p>
<pre><code class="language-javascript">import { renderToPipeableStream } from &quot;react-server-dom-webpack/server.node&quot;

// 注意是普通函数，而非 async 函数
export function jsxGenerator(url) {
  return renderToPipeableStream(&lt;Router url={url} /&gt;)
}
</code></pre>
<p>修改 <code>server/rsc.ts</code>，代码如下：</p>
<pre><code class="language-javascript">app.get(&quot;/:route(*)&quot;, async (req, res) =&gt; {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const { pipe } = jsxGenerator(url);
  pipe(res)
});
</code></pre>
<p>此时我们就完成了 RSC 组件的流式渲染。但命令行会出现报错：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a483f88806a44bccbf4605ad64e7a13c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2382&h=250&s=109585&e=png&b=1f1f1f" alt="image.png"></p>
<p>这是因为 React Server Components 需要 <code>react-server</code> condition（关于 condition，参考 <a href="https://nodejs.org/api/cli.html#-c-condition---conditionscondition">Node 官方文档</a>）。</p>
<p>我们修改 <code>package.json</code>，代码如下：</p>
<pre><code class="language-javascript">{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;concurrently \&quot;npm run start:ssr\&quot; \&quot;npm run start:rsc\&quot;&quot;,
    &quot;start:rsc&quot;: &quot;tsx watch --conditions=react-server ./server/rsc.ts&quot;,
    &quot;start:ssr&quot;: &quot;tsx watch ./server/ssr.ts&quot;
  }
}
</code></pre>
<p>运行 <code>npm start</code>，你会发现此时还是有报错，页面也是空白。但是没有关系，我们慢慢解决，访问 <a href="http://localhost:3001/hello">http://localhost:3001/hello</a>，也就是直接访问 RSC 服务，效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5eba44e5a1d417d9e65825058a455d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3858&h=868&s=426399&e=png&b=fefefe" alt="image.png"></p>
<p>借助 react-server-dom-webpack，我们已经将 React Server Component 渲染成流的格式，但是 SSR Server 和客户端还不能做正确的解析，所以出现了错误。</p>
<h2>Step2：服务端解析 RSC Payload</h2>
<p>SSR Server 该如何解析返回的 RSC Payload 呢？</p>
<p>其实在实现思路一节已经讲过了，借助 createFromNodeStream 和 renderToPipeableStream。首先安装 <a href="https://www.npmjs.com/package/node-fetch">node-fetch</a> 这个包：</p>
<pre><code class="language-javascript">npm i node-fetch
</code></pre>
<p>这是因为我们使用的毕竟是 react-server-dom-webpack 的 createFromNodeStream，既然是 NodeStream，自然是要用 Node 的 Stream。</p>
<p>修改 <code>server/ssr.js</code>，代码如下：</p>
<pre><code class="language-javascript">import express from &quot;express&quot;;
import { readFile } from &quot;fs/promises&quot;;
import fetch from &#39;node-fetch&#39;;
import { renderToPipeableStream } from &quot;react-dom/server&quot;
import { createFromNodeStream } from &quot;react-server-dom-webpack/client&quot;

const app = express();

app.get(&quot;/:route(*)&quot;, async (req, res) =&gt; {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // client.js
  if (url.pathname === &quot;/client.js&quot;) {
    const content = await readFile(&quot;./client.js&quot;, &quot;utf8&quot;);
    res.setHeader(&quot;Content-Type&quot;, &quot;text/javascript&quot;);
    res.end(content);
    return;
  }

  const response = await fetch(&quot;http://127.0.0.1:3001&quot; + url.pathname);

  if (!response.ok) {
    res.statusCode = response.status;
    res.end();
    return;
  }
  const stream = response.body;

  // 获取客户端 JSX 对象
  if (url.searchParams.has(&quot;jsx&quot;)) {
    res.set(&quot;Content-type&quot;, &quot;text/x-component&quot;)
    stream.on(&quot;data&quot;, (data) =&gt; {
      res.write(data)
    })
    stream.on(&quot;end&quot;, (data) =&gt; {
      res.end()
    })
  }
  // 获取 HTML
  else {
    const root = await createFromNodeStream(stream, {})
    res.set(&quot;Content-type&quot;, &quot;text/html&quot;)
    const { pipe } = renderToPipeableStream(root)
    pipe(res)
  }
});

app.listen(3000, (err) =&gt; {
  if (err) return console.error(err);
  return console.log(`Server is listening on 3000`);
});
</code></pre>
<p>fetch 的 response.body 会返回一个 Stream，createFromNodeStream 传入的便是这个 Steam，最终返回的 root 是页面的 JSX 对象，我们有调用了 renderToPipeableStream 将其渲染为流式 HTML。</p>
<p>此时访问 <a href="http://localhost:3000/">http://localhost:3000/</a>，页面已经可以正常渲染：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08029f02a31b44c9b8f2c2772f4655a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3922&h=2038&s=447600&e=png&b=fbfaf9" alt="image.png"></p>
<p>尽管页面正常渲染，但注意这里，页面的请求数量只有 3 个，没有 <code>client.js</code>，也没有 react 相关的 JS。</p>
<p>这是因为以前我们是在将 clientJSX 渲染成 HTML 后再拼接的 HTML，但是这里我们直接返回了渲染结果，所以没有机会写入 client.js。</p>
<p>此外，访问 <a href="http://localhost:3000/?jsx">http://localhost:3000/?jsx</a>，效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2e0ff40742843b7abb1ec5d335d2391~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3668&h=960&s=555683&e=png&b=fbfafa" alt="image.png"></p>
<p>你可以发现，无论是 <code>/</code>的 Transfer-Encoding 响应头还是 <code>/?jsx</code> 的 Transfer-Encoding 响应头都是 chunked。这说明 HTML 和 RSC Payload 都已经实现了 Streaming。</p>
<h2>Step3：客户端解析 RSC Payload</h2>
<p>回到刚才的问题，如何引入 client.js 呢？</p>
<p>我们可以改为在 components.tsx 的 <code>&lt;Layout&gt;</code>中引入，修改 <code>components.tsx</code>，代码如下：</p>
<pre><code class="language-javascript">const importMap = `{
  &quot;imports&quot;: {
    &quot;react&quot;: &quot;https://esm.sh/react@18.3.0-canary-c3048aab4-20240326?dev&quot;,
        &quot;react-dom/client&quot;: &quot;https://esm.sh/react-dom@18.3.0-canary-c3048aab4-20240326/client?dev&quot;,
        &quot;react-server-dom-webpack&quot;: &quot;https://esm.sh/react-server-dom-webpack@18.3.0-canary-c3048aab4-20240326/client?dev&quot;
  }
}`

export function Layout({ children }) {
  const author = &quot;YaYu&quot;;
  return (
    &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;My blog&lt;/title&gt;
      &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
      &lt;script dangerouslySetInnerHTML={{ __html: `window.__webpack_require__ = async (id) =&gt; {
          return import(id)
        }` }}&gt;
      &lt;/script&gt;
      &lt;script
          type=&quot;importmap&quot;
          dangerouslySetInnerHTML={{ __html: importMap }}
      &gt;&lt;/script&gt;
      &lt;script type=&quot;module&quot; src=&quot;/client.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body className=&quot;p-5&quot;&gt;
      &lt;nav className=&quot;flex items-center justify-center gap-10 text-blue-600&quot;&gt;
        &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;
      &lt;/nav&gt;
      &lt;input required className=&quot;block w-full rounded-md border-0 px-1.5 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6&quot; /&gt;
      &lt;main&gt;{children}&lt;/main&gt;
      &lt;Footer author={author} /&gt;
    &lt;/body&gt;
  &lt;/html&gt;
  );
}
</code></pre>
<p>修改 <code>client.js</code>，完整代码如下：</p>
<pre><code class="language-javascript">import * as React from &quot;react&quot;
import { use, useState, startTransition } from &quot;react&quot;
import { createFromFetch } from &quot;react-server-dom-webpack&quot;
import { hydrateRoot } from &#39;react-dom/client&#39;;

// 客户端路由缓存
let clientJSXCache = {}
let currentPathname = window.location.pathname
let updateRoot

function Shell({ data }) {
  console.log(&quot;Shell&quot;, data)
  const [root, setRoot] = useState(use(data))
  clientJSXCache[currentPathname] = root
  updateRoot = setRoot
  return root
}

let data = createFromFetch(
  fetch(currentPathname + &#39;?jsx&#39;)
)

hydrateRoot(document, React.createElement(Shell, { data }))

async function navigate(pathname) {
  currentPathname = pathname;
  if (clientJSXCache[pathname]) {
    updateRoot(clientJSXCache[pathname])
    return
  } else {
    const response = fetch(pathname + &#39;?jsx&#39;)
    const root = await createFromFetch(response)
    clientJSXCache[pathname] = root
    startTransition(() =&gt; {
      updateRoot(root)
    })
  }
}

window.addEventListener(&quot;click&quot;, (e) =&gt; {
  // 忽略非 &lt;a&gt; 标签点击事件
  if (e.target.tagName !== &quot;A&quot;) {
    return;
  }
  // 忽略 &quot;open in a new tab&quot;.
  if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {
    return;
  }
  // 忽略外部链接
  const href = e.target.getAttribute(&quot;href&quot;);
  if (!href.startsWith(&quot;/&quot;)) {
    return;
  }
  // 组件浏览器重新加载页面
  e.preventDefault();
  // 但是 URL 还是要更新
  window.history.pushState(null, null, href);
  // 调用我们自己的导航逻辑
  navigate(href);
}, true);

window.addEventListener(&quot;popstate&quot;, () =&gt; {
  // 处理浏览器前进后退事件
  navigate(window.location.pathname);
});
</code></pre>
<p>此时页面已经可以正常运行：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9a70d464c774e5dbc48ae990a688da2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606&h=1015&s=333179&e=gif&f=59&b=fafafa" alt="react-rsc-13.gif"></p>
<p>现在 Suspense 组件也能正常使用了，修改 <code>components.tsx</code>，代码如下：</p>
<pre><code class="language-javascript">import React, { Suspense } from &#39;react&#39;;
const sleep = ms =&gt; new Promise(r =&gt; setTimeout(r, ms));

export async function IndexPage() {
  const files = await readdir(&quot;./posts&quot;);
  const slugs = files.map((file) =&gt;
    file.slice(0, file.lastIndexOf(&quot;.&quot;))
  );

  return (
    &lt;section&gt;
      &lt;h1&gt;Blog List:&lt;/h1&gt;
      &lt;div&gt;
        {slugs.map((slug, index) =&gt; (
          &lt;Suspense key={index} fallback={&lt;p&gt;Loading Post...&lt;/p&gt;}&gt;
            &lt;Post slug={slug} /&gt;
          &lt;/Suspense&gt;
        ))}
      &lt;/div&gt;
    &lt;/section&gt;
  );
}

export function PostPage({ slug }) {
  return (
    &lt;Suspense fallback={&lt;p&gt;Loading Post...&lt;/p&gt;}&gt;
      &lt;Post slug={slug} /&gt;
    &lt;/Suspense&gt;
  );
}

async function Post({ slug }) {
  let content = await readFile(&quot;./posts/&quot; + slug + &quot;.txt&quot;, &quot;utf8&quot;);
  await sleep(2000)
  return (
    &lt;section&gt;
      &lt;a className=&quot;text-blue-600&quot; href={&quot;/&quot; + slug}&gt;{slug}&lt;/a&gt;
      &lt;article className=&quot;h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center&quot;&gt;{content}&lt;/article&gt;
    &lt;/section&gt;
  )
}
</code></pre>
<p>为了让效果明显，我们为 Post 组件添加了 2s 的延时，并在 IndexPage 和 PostPage 中使用了 Suspense。</p>
<p>最终的交互效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf7b532018104bda82b61ff7908e23d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606&h=1015&s=501487&e=gif&f=91&b=fafafa" alt="react-rsc-14.gif"></p>
<blockquote>
<ol>
<li>功能实现：Streaming 与 Suspense</li>
<li>源码地址：<a href="https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-10">https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-10</a></li>
<li>下载代码：<code>git clone -b react-rsc-10 git@github.com:mqyqingfeng/next-app-demo.git</code></li>
</ol>
</blockquote>
<h2>参考链接</h2>
<ol>
<li><a href="https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack">https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack</a></li>
<li><a href="https://timtech.blog/posts/react-server-components-rsc-no-framework/">https://timtech.blog/posts/react-server-components-rsc-no-framework/</a></li>
<li><a href="https://react.dev/reference/react-dom/server/renderToPipeableStream">https://react.dev/reference/react-dom/server/renderToPipeableStream</a></li>
</ol>

</body>
</html>
  