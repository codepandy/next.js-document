
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>72-源码篇  手写 React SSG 和 ISR</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>上篇我们手写了一个 React SSR，实现了基本的服务端渲染和客户端绑定事件。</p>
<p>本篇我们先继续完善 React SSR，并在此基础上实现 React SSG 和 React ISR。</p>
<h2>1. 优化 Ract SSR</h2>
<h3>Step1：实现 getServerSideProps</h3>
<p>在使用 Next.js Pages Router 的时候，经常会用到一个 <a href="https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props">getServerSideProps</a> 的 API，用于在页面请求时获取数据渲染页面的内容。举个例子：</p>
<pre><code class="language-javascript">export async function getServerSideProps() {
  // 获取数据
  const res = await fetch(&#39;https://api.github.com/repos/vercel/next.js&#39;)
  const repo = await res.json()
  // 通过 props 将数据传给 page
  return { props: { repo } }
}
 
export default function Page({ repo }) {
  return (
    &lt;main&gt;
      &lt;p&gt;{repo.stargazers_count}&lt;/p&gt;
    &lt;/main&gt;
  )
}
</code></pre>
<p>这个功能该怎么实现呢？</p>
<p>其实思路很简单：import 该文件，获取导出的 getServerSideProps 函数。然后在服务端调用该函数，最后将返回的数据传入到组件中。</p>
<p>修改 <code>server.js</code>，完整代码如下：</p>
<pre><code class="language-jsx">import express from &#39;express&#39;
import React from &#39;react&#39;
import { renderToString } from &#39;react-dom/server&#39;
import { readdirSync } from &quot;fs&quot;;
import { join } from &quot;path&quot;;

const app = express()
app.use(express.static(&#39;public&#39;));

app.get(&quot;/&quot;, async (req, res) =&gt; {
    const file = await import(`./pages/index.js`);
    let propsObj = {};
    if (file.getServerSideProps) {
      const { props } = await file.getServerSideProps({ query: req.query });
      propsObj = props
    }
    const Component = file.default;

    const content = renderToString(&lt;Component {...propsObj} /&gt;)
    res.send(`
    &lt;html&gt;
       &lt;head&gt;
           &lt;title&gt;Tiny React SSR&lt;/title&gt;
       &lt;/head&gt;
       &lt;body&gt;
        &lt;div id=&#39;root&#39;&gt;${content}&lt;/div&gt;
        &lt;script src=&quot;/client.bundle.js&quot;&gt;&lt;/script&gt;
       &lt;/body&gt;
    &lt;/html&gt;
    `)
})

app.listen(3000, () =&gt; console.log(&#39;listening on port 3000!&#39;))
</code></pre>
<p>为了测试效果，修改 <code>pages/index.js</code>，代码如下：</p>
<pre><code class="language-javascript">import React from &#39;react&#39;;

export async function getServerSideProps() {
  const res = await fetch(&#39;https://api.thecatapi.com/v1/images/search&#39;)
  const cat = await res.json()
  return { props: { cat } }
}
 
export default function Page({ cat }) {
  return &lt;img src={cat[0].url} width=&quot;200&quot; /&gt;
}
</code></pre>
<p>运行 <code>npm start</code>，访问 <code>http://localhost:3000/</code>，此时页面空白且有报错：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ef5ee83c8c344469536a59195a577a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3464&h=1312&s=692215&e=png&b=faf4f4" alt="image.png"></p>
<p>但是让我们查看 localhost 页面的 HTML 返回：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/388e0271d3fd4be0aaa0814a876bee9a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3640&h=842&s=274474&e=png&b=ffffff" alt="image.png">
至少 HTML 返回是正确的，并成功的获取了数据。</p>
<p>可是为什么会有报错呢？</p>
<p>根据报错的信息，是水合（hydration）时出现了错误。这是因为服务端渲染的 HTML 和客户端渲染的 HTML 并不匹配（前面我们说过，服务端渲染和客户端渲染一致，是复用 DOM 节点进行水合的前提）。</p>
<p>服务端渲染的时候我们调用接口传入了数据，但是客户端渲染的时候并没有调用接口传入数据，自然渲染不一致，导致了报错。</p>
<p>所以客户端渲染的时候也要获取数据，才能保证两端渲染一致。</p>
<p>尴尬的是我们的接口是一个随机返回数据的接口，每次调用都会返回不同的数据。</p>
<p>注：其实这种每次调用数据返回不一致的情况很常见，比如 feeds 流，客户端调用和服务端调用尽管时间差不了几秒，但可能数据已经发生了更改。</p>
<p>最为简单的方式是将数据写入 HTML 脚本中，然后客户端渲染的时候直接获取。</p>
<p>修改 <code>server.js</code>，完整代码如下：</p>
<pre><code class="language-javascript">import express from &#39;express&#39;
import React from &#39;react&#39;
import { renderToString } from &#39;react-dom/server&#39;
import { readdirSync } from &quot;fs&quot;;
import { join } from &quot;path&quot;;

const app = express()
app.use(express.static(&#39;public&#39;));

app.get(&quot;/&quot;, async (req, res) =&gt; {
    const file = await import(`./pages/index.js`);
    let propsObj = {};
    if (file.getServerSideProps) {
      const { props } = await file.getServerSideProps({ query: req.query });
      propsObj = props
    }
    const Component = file.default;

    const content = renderToString(&lt;Component {...propsObj} /&gt;)
    res.send(`
    &lt;html&gt;
       &lt;head&gt;
           &lt;title&gt;Tiny React SSR&lt;/title&gt;
       &lt;/head&gt;
       &lt;body&gt;
        &lt;div id=&#39;root&#39;&gt;${content}&lt;/div&gt;
        &lt;script&gt;
          window.__DATA__ = ${JSON.stringify(propsObj)}
        &lt;/script&gt;
        &lt;script src=&quot;/client.bundle.js&quot;&gt;&lt;/script&gt;
       &lt;/body&gt;
    &lt;/html&gt;
    `)
})

app.listen(3000, () =&gt; console.log(&#39;listening on port 3000!&#39;))
</code></pre>
<p>我们将数据放到 <code>window.__DATA__</code>变量中，然后在 JS 文件中就可以直接获取。</p>
<p>修改 <code>client.js</code>，代码如下：</p>
<pre><code class="language-javascript">import React from &#39;react&#39;;
import { hydrateRoot } from &#39;react-dom/client&#39;;
import App from&#39;./pages/index&#39;

hydrateRoot(document.getElementById(&#39;root&#39;), &lt;App {...window.__DATA__}/&gt;);
</code></pre>
<p>重新运行 <code>npm start</code>，访问 <code>http://localhost:3000/</code>，现在页面渲染正常了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a61c28bf89b4be0adc388c4cbeddb48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3584&h=1094&s=741932&e=png&b=fefdfd" alt="image.png"></p>
<blockquote>
<ol>
<li>功能实现：React SSR 实现 gerServerSideProps</li>
<li>源码地址：<a href="https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-2">https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-2</a></li>
<li>下载代码：<code>git clone -b react-ssr-2 git@github.com:mqyqingfeng/next-app-demo.git</code></li>
</ol>
</blockquote>
<h3>Step2：实现路由</h3>
<p>Next.js 的路由基于的是文件系统，也就是说，一个文件就可以是一个路由。</p>
<p>举个例子，在 Next.js 的 Pages Router 下，你在 <code>pages</code> 目录下创建一个 <code>index.js</code> 文件，它会直接映射到 <code>/</code> 路由地址：</p>
<pre><code class="language-javascript">import React from &#39;react&#39;
export default () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;
</code></pre>
<p>在 <code>pages</code> 目录下创建一个 <code>about.js</code> 文件，它会直接映射到 <code>/about</code> 路由地址：</p>
<pre><code class="language-javascript">import React from &#39;react&#39;
export default () =&gt; &lt;h1&gt;About us&lt;/h1&gt;
</code></pre>
<p>如果我们要实现这个效果，该怎么实现呢？</p>
<p>实现思路其实很简单，判断路由地址，导入对应的模块进行渲染即可。</p>
<p>修改 <code>server.js</code>，完整代码如下：</p>
<pre><code class="language-javascript">import express from &#39;express&#39;
import React from &#39;react&#39;
import { renderToString } from &#39;react-dom/server&#39;
import { readdirSync } from &quot;fs&quot;;
import { join } from &quot;path&quot;;

const app = express()
app.use(express.static(&#39;public&#39;));

const pagesDir = join(process.cwd(), &quot;/pages&quot;)
const pages = readdirSync(pagesDir).map(page =&gt; page.split(&quot;.&quot;)[0]);

app.get(/.*$/, async (req, res) =&gt; {

  const path = req.path.split(&#39;/&#39;)[1]
  const page = path ? path : &#39;index&#39;

  if (pages.includes(page)) {
    const file = await import(`./pages/${page}.js`);
    const Component = file.default;

    let propsObj = {};
    if (file.getServerSideProps) {
      const { props } = await file.getServerSideProps({ query: req.query });
      propsObj = props
    }

    const content = renderToString(&lt;Component {...propsObj} /&gt;)
    res.send(`
      &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Tiny React SSR&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
          &lt;div id=&#39;root&#39;&gt;${content}&lt;/div&gt;
          &lt;script&gt;
            window.__DATA__ = ${JSON.stringify({
              props: propsObj,
              page: page
            })}
          &lt;/script&gt;
          &lt;script src=&quot;/client.bundle.js&quot;&gt;&lt;/script&gt;
         &lt;/body&gt;
      &lt;/html&gt;
      `)
  } else {
    return res.status(200).json({ message: `${page} not found in ${pages}` });
  }
})

app.listen(3000, () =&gt; console.log(&#39;listening on port 3000!&#39;))
</code></pre>
<p>但最为麻烦的地方是 <code>client.js</code>，之前的代码是：</p>
<pre><code class="language-javascript">import React from &#39;react&#39;;
import { hydrateRoot } from &#39;react-dom/client&#39;;
import App from&#39;./pages/index&#39;

hydrateRoot(document.getElementById(&#39;root&#39;), &lt;App /&gt;);
</code></pre>
<p>我们是固定导入的 App 组件，现在改成了跟随路由导入不同的组件，也就是说导入的组件要跟随路由不同而不同，然后打包成不同的 client.bundle.js。</p>
<p>一种方案是打包 pages 下的文件，分别对应生成不同的 bundle.js，比如 <code>index.js</code>生成 <code>index.bundle.js</code>，<code>cat.js</code>生成 <code>cat.bundle.js</code>，然后我们根据路由引入不同的 bundle.js。</p>
<p>一种方案可以参考最早的 <a href="https://github.com/vercel/next.js/tree/1.0.0">Next.js v1.0.0 源码</a>，可以说是简单粗暴的解决了这个问题，那就是用 node.fs 读取 pages 下的文件，然后放入到 <code>window.__DATA__</code>，然后客户端渲染的时候获取组件代码进行渲染，伪代码如下：</p>
<pre><code class="language-javascript">const {
  __NEXT_DATA__: { component }
} = window

const Component = evalScript(component).default

render(createElement(Component, appProps), container)
</code></pre>
<p>这两种方案都有些麻烦，这里我们直接使用 Webpack 动态加载来实现，修改 <code>client.js</code>，代码如下：</p>
<pre><code class="language-javascript">import React from &#39;react&#39;;
import { hydrateRoot } from &#39;react-dom/client&#39;;

const { props, page } = window.__DATA__

const importFile = async (path) =&gt; {
  return await import (`./pages/${path}.js`)
}
const data = await importFile(page)
const Component = data.default

hydrateRoot(document.getElementById(&#39;root&#39;), &lt;Component {...props} /&gt;);
</code></pre>
<p>在 <code>pages</code> 目录下再新建一个 counter.js，代码如下:</p>
<pre><code class="language-js">import React, { useState } from &#39;react&#39;;

export default function MyApp() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;h1&gt;Counters { count } times&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>重新运行 <code>npm start</code>，访问 <code>http://localhost:3000/</code>，效果如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc08b7fc236d4e65a93454f26269b9c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1580&h=646&s=258580&e=gif&f=33&b=fcfbfc" alt="react-rsc-19.gif"></p>
<p>当访问未定义的路由时，会出现错误提示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/757b9567dd4740e98466694f8c63dd6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1470&h=332&s=38968&e=png&b=fefefe" alt="image.png"></p>
<blockquote>
<ol>
<li>功能实现：React SSR 实现路由</li>
<li>源码地址：<a href="https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-3">https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-3</a></li>
<li>下载代码：<code>git clone -b react-ssr-3 git@github.com:mqyqingfeng/next-app-demo.git</code></li>
</ol>
</blockquote>
<h2>2. 实现 React SSG</h2>
<p>SSG 会在构建阶段，就将页面编译为静态的 HTML 文件。</p>
<p>其实核心方法不变，还是用 renderToString，只不过不写在路由中，而是渲染成具体的 HTML 文件。</p>
<p>让我们新建一个 <code>build.js</code>，代码如下：</p>
<pre><code class="language-javascript">import { existsSync, readdirSync, mkdirSync, writeFileSync } from &#39;node:fs&#39;;
import { renderToString } from &#39;react-dom/server&#39;;
import { createElement } from &#39;react&#39;
import { join } from &quot;path&quot;;

const pagesDir = join(process.cwd(), &quot;/pages&quot;)
const pages = readdirSync(pagesDir).map(page =&gt; page.split(&quot;.&quot;)[0]);

if (!existsSync(&#39;output&#39;)) {
  mkdirSync(&#39;output&#39;);
}

pages.forEach(async (page) =&gt; {
  const file = await import(`./pages/${page}.js`);
  const Component = file.default;

  let propsObj = {};
  if (file.getServerSideProps) {
    const { props } = await file.getServerSideProps();
    propsObj = props
  }
  
  const content = renderToString(createElement(Component, propsObj))
  writeFileSync(
    `output/${page}.html`,
    `    &lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Tiny React SSR&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
     &lt;div id=&#39;root&#39;&gt;${content}&lt;/div&gt;
     &lt;script&gt;
       window.__DATA__ = ${JSON.stringify({
      props: propsObj,
      page: page
    })}
     &lt;/script&gt;
     &lt;script src=&quot;../public/client.bundle.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
 &lt;/html&gt;`
  );
})
</code></pre>
<p>为了让 node 能够正确运行 <code>build.js</code>，我们需要新建一个 <code>webpack.build.js</code> 文件用于打包 build.js 文件：</p>
<pre><code class="language-javascript">const path = require(&#39;path&#39;) 

module.exports = {
  mode:&#39;development&#39;,
  target: &#39;node&#39;,
  entry: &#39;./build.js&#39;,       
  output: {                     
    filename: &#39;build.bundle.js&#39;,    
    path: path.resolve(__dirname, &#39;build&#39;)    
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: &#39;babel-loader&#39;,
          options: {
            presets: [&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;]
          }
        }
      }
    ]
  }
}
</code></pre>
<p>现在让我们在 <code>package.json</code> 中添加一个脚本命令：</p>
<pre><code class="language-javascript">{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config webpack.client.js &amp;&amp; webpack --config webpack.build.js &amp;&amp; node ./build/build.bundle.js&quot;
  }
}
</code></pre>
<p>现在运行 <code>npm run build</code>，<code>output</code>文件夹下会生成两个 HTML 文件：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf0680ae0c5415a962fc62c458a1fa4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2176&h=770&s=226394&e=png&b=fcfcfc" alt="image.png"></p>
<p>浏览器直接打开这两个文件，都能正常运行：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c47017d707429ca5ffeefff0463f3b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=910&h=314&s=127985&e=gif&f=32&b=fefcfc" alt="react-rsc-20.gif"></p>
<blockquote>
<ol>
<li>功能实现：React SSG</li>
<li>源码地址：<a href="https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-4">https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-4</a></li>
<li>下载代码：<code>git clone -b react-ssr-4 git@github.com:mqyqingfeng/next-app-demo.git</code></li>
</ol>
</blockquote>
<h2>3. 实现 React ISR</h2>
<p>SSG 都实现了，就让我们再实现一个 ISR 吧！</p>
<p>其实原理很简单，就是在访问的时候检查是否过期，如果过期了，就重新生成 HTML 文件。</p>
<p>新建 <code>isr.js</code>，代码如下：</p>
<pre><code class="language-javascript">import express from &#39;express&#39;
import { createElement } from &#39;react&#39;
import { renderToString } from &#39;react-dom/server&#39;
import { existsSync, readdirSync, mkdirSync, writeFileSync, stat } from &#39;node:fs&#39;;
import { join } from &quot;path&quot;;

const app = express()
app.use(express.static(&#39;public&#39;));

async function asyncForEach(array, callback) {
  for (let index = 0; index &lt; array.length; index++) {
    await callback(array[index], index, array);
  }
}

const pagesDir = join(process.cwd(), &quot;/pages&quot;)
const pages = readdirSync(pagesDir).map(page =&gt; page.split(&quot;.&quot;)[0]);

const expiresTime = 1000 * 10;

async function build() {
  if (!existsSync(&#39;output&#39;)) {
    mkdirSync(&#39;output&#39;);
  }

  await asyncForEach(pages, async (page) =&gt; {
    const file = await import(`./pages/${page}.js`);
    const Component = file.default;

    let propsObj = {};
    if (file.getServerSideProps) {
      const { props } = await file.getServerSideProps();
      propsObj = props
    }

    const content = renderToString(createElement(Component, propsObj))
    writeFileSync(
      `output/${page}.html`,
      `    &lt;html&gt;
      &lt;head&gt;
          &lt;title&gt;Tiny React SSR&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
       &lt;div id=&#39;root&#39;&gt;${content}&lt;/div&gt;
       &lt;script&gt;
         window.__DATA__ = ${JSON.stringify({
        props: propsObj,
        page: page
      })}
       &lt;/script&gt;
       &lt;script src=&quot;/client.bundle.js&quot;&gt;&lt;/script&gt;
      &lt;/body&gt;
   &lt;/html&gt;`
    );
  })
}

app.get(/.*$/, async (req, res) =&gt; {

  const path = req.path.split(&#39;/&#39;)[1]
  const page = path ? path : &#39;index&#39;

  if (pages.includes(page)) {

    const htmlPath = join(&#39;./output&#39;, page + &#39;.html&#39;)

    stat(htmlPath, async function (err, stats) {
      if (err) {
          await build()
          return res.sendFile(join(process.cwd(), &quot;output&quot;, page + &#39;.html&#39;));
      }
      if (Date.now() - stats.mtime &gt; expiresTime) {
        await build()
        return res.sendFile(join(process.cwd(), &quot;output&quot;, page + &#39;.html&#39;));
      } else {
        return res.sendFile(join(process.cwd(), &quot;output&quot;, page + &#39;.html&#39;));
      }
    });
  } else {
    return res.status(200).json({ message: `${page} not found in ${pages}` });
  }
})

app.listen(3000, () =&gt; console.log(&#39;listening on port 3000!&#39;))
</code></pre>
<p>为了编译 isr.js 文件，新建 <code>webpack.isr.js</code>，代码如下：</p>
<pre><code class="language-javascript">const path = require(&#39;path&#39;) 

module.exports = {
  mode:&#39;development&#39;,
  target: &#39;node&#39;,
  entry: &#39;./isr.js&#39;,       
  output: {                     
    filename: &#39;isr.bundle.js&#39;,    
    path: path.resolve(__dirname, &#39;build&#39;)    
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: &#39;babel-loader&#39;,
          options: {
            presets: [&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;]
          }
        }
      }
    ]
  }
}
</code></pre>
<p><code>packages.json</code>文件添加对应的脚本命令：</p>
<pre><code class="language-javascript">{
  &quot;scripts&quot;: {
    &quot;isr&quot;: &quot;webpack --config webpack.isr.js &amp;&amp; node ./build/isr.bundle.js&quot;
  }
}
</code></pre>
<p>运行 <code>npm run isr</code>，交互效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b83285f3c6614c1e8b7d160638141fce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=821&h=425&s=263452&e=gif&f=93&b=fefefe" alt="react-ssr-3.gif"></p>
<p>可以看到，10s 后图片数据发生了更新。</p>
<p>注：当然这个 ISR 的实现并不算贴近 Next.js 的 ISR 实现，Next.js 的 ISR 是在超过验证时间的首次，依然返回之前的结果，同时进行更新，然后下次访问才返回新的结果。这里我们直接同步构建并返回了新的结果。</p>
<blockquote>
<ol>
<li>功能实现：React ISR</li>
<li>源码地址：<a href="https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-5">https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-5</a></li>
<li>下载代码：<code>git clone -b react-ssr-5 git@github.com:mqyqingfeng/next-app-demo.git</code></li>
</ol>
</blockquote>
<h2>总结</h2>
<p>本篇我们优化了 React SSR 的功能，并在此基础上实现了 React SSG 和 React ISR，但至此实现的都是 Next.js 的 Pages Router，也就是 Next.js v13 之前的实现。</p>
<p>Next.js v13 推出了基于 React Server Components 的 App Router，下篇开始，我们会进入 RSC 的实现讲解。</p>

</body>
</html>
  