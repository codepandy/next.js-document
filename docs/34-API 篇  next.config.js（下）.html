
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>34-API 篇  next.config.js（下）</title>
  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    pre {
      background-color: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
    }
    code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
  </style>
</head>
<body>
<h2>前言</h2>
<p>本篇我们讲解 <code>next.config.js</code> 剩下的 31 个配置项。</p>
<h2>1. assetPrefix</h2>
<p>assetPrefix 用于设置资源前缀，举个例子：</p>
<pre><code class="language-javascript">// next.config.js
const isProd = process.env.NODE_ENV === &#39;production&#39;
 
module.exports = {
  // Use the CDN in production and localhost for development.
  assetPrefix: isProd ? &#39;https://cdn.mydomain.com&#39; : undefined,
}
</code></pre>
<p>Next.js 会自动为从 <code>/_next</code>路径（<code>.next/static/</code>文件夹）加载的 JavaScript 和 CSS 文件添加资源前缀。以这个例子为例，当请求 JS 代码片段的时候，原本地址是：</p>
<pre><code>/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
</code></pre>
<p>会变成：</p>
<pre><code>https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
</code></pre>
<p>注意：虽然这里请求的路径是在 <code>/_next</code>下，但实际文件在 <code>.next/</code> 下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7909926b75be482794f1ef581f49490a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1652&h=194&s=91172&e=png&a=1&b=1e2022" alt="image.png"></p>
<p>让我们在开发环境中测试一下这个配置，原本请求的地址是：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6055de0f0211497cbddcdf245c836cc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1988&h=350&s=120792&e=png&b=2a2a2a" alt="image.png"></p>
<p>配置后会变成：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632ded0ea9d645609a1179425ed2afbb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2020&h=278&s=94793&e=png&b=303030" alt="image.png"></p>
<p>注意：</p>
<ol>
<li>你应该上传到 CDN 的只有 <code>.next/static/</code>的内容，不要上传 <code>.next/</code> 剩余的部分，这会导致你暴露服务端代码和其他配置。</li>
<li><code>assetPrefix</code>不会影响 <code>public</code> 文件夹下的文件。对于 <code>public</code> 下的资源，你需要自己处理前缀。</li>
</ol>
<h2>2. basePath</h2>
<p><code>basePath</code> 用于设置应用的路径前缀。举个例子：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  basePath: &#39;/docs&#39;,
}
</code></pre>
<p>修改 <code>app/page.js</code>的代码为：</p>
<pre><code class="language-javascript">import Link from &#39;next/link&#39;

export default function HomePage() {
  return (
    &lt;&gt;
      &lt;Link href=&quot;/about&quot;&gt;About Page&lt;/Link&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p>使用 <code>basePath</code> 后，直接访问 <code>/</code>会导致 404 错误：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5e0c817eaa3482d90a35b5bac3b659c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=370&s=36505&e=png&b=000000" alt="image.png"></p>
<p>你应该访问 <code>/docs</code>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfc1763307904f718a7c8fe700bc2c68~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=768&h=246&s=25063&e=png&b=ffffff" alt="image.png">
如果你不希望访问 <code>/</code> 导致 404 错误，那你可以来个重写或者重定向：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  basePath: &#39;/docs&#39;,
  async redirects() {
    return [
        {
            source: &#39;/&#39;,
            destination: &#39;/docs&#39;,
            basePath: false,
            permanent: false
        }
    ]
  }
}
</code></pre>
<p>当你使用 <code>next/link</code> 和 <code>next/router</code> （App Router 下使用 <code>next/navigation</code>）链接到其他页面时，<code>basePath</code> 就会自动应用。举个例子，<code>/about</code> 会自动变成 <code>/docs/about</code>：</p>
<pre><code class="language-javascript">export default function HomePage() {
  return (
    &lt;&gt;
      &lt;Link href=&quot;/about&quot;&gt;About Page&lt;/Link&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p>输出的 HTML 为：</p>
<pre><code class="language-html">&lt;a href=&quot;/docs/about&quot;&gt;About Page&lt;/a&gt;
</code></pre>
<p>当你使用 <code>next/image</code>组件的时候，你应该在 <code>src</code> 前添加 <code>basePath</code>（如果你使用静态导入就正常处理即可）：</p>
<pre><code class="language-javascript">import Image from &#39;next/image&#39;
 
function Home() {
  return (
    &lt;&gt;
      &lt;h1&gt;My Homepage&lt;/h1&gt;
      &lt;Image
        src=&quot;/docs/me.png&quot;
        alt=&quot;Picture of the author&quot;
        width={500}
        height={500}
      /&gt;
      &lt;p&gt;Welcome to my homepage!&lt;/p&gt;
    &lt;/&gt;
  )
}
 
export default Home
</code></pre>
<p>在这个例子中，图片放在 <code>/public</code>目录下，正常使用 <code>/me.png</code> 即可访问，设置 <code>basePath</code> 为 <code>/docs</code> 后，应该改为使用 <code>/docs/me.png</code>。</p>
<h2>3. compress</h2>
<p>Next.js 提供 gzip 压缩来压缩渲染的内容和静态文件。如果你想禁用压缩功能：</p>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  compress: false,
}
</code></pre>
<h2>4. devIndicators</h2>
<p>当你编辑代码，Next.js 正在编译应用的时候，页面右下角会有一个编译指示器。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9013933fbed34b7f8d155aac131d2e58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=406&h=256&s=17318&e=gif&f=13&b=ffffff" alt="FVWEU.gif"></p>
<p>这个指示器只会在开发模式下展示，生产环境中不会展示。如果你想更改它的位置，就比如它跟页面的其他元素位置发生冲突了：</p>
<pre><code class="language-javascript">module.exports = {
  devIndicators: {
    buildActivityPosition: &#39;bottom-right&#39;,
  },
}
</code></pre>
<p>默认值是 <code>bottom-right</code>，其他值还有<code> bottom-left</code>、<code>top-right</code>、<code>top-left</code>。</p>
<p>如果你想禁用它：</p>
<pre><code class="language-javascript">module.exports = {
  devIndicators: {
    buildActivity: false,
  },
}
</code></pre>
<h2>5. distDir</h2>
<p><code>distDir</code> 用于自定义构建目录，默认是 <code>.next</code>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11046c79e6a24fb49cfb437a3140ec4f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1652&h=194&s=91172&e=png&a=1&b=1e2022" alt="image.png"></p>
<p>举个例子：</p>
<pre><code class="language-javascript">module.exports = {
  distDir: &#39;build&#39;,
}
</code></pre>
<p>现在如果你运行 <code>next build</code>，Next.js 会使用 <code>build</code> 文件夹而不是 <code>.next</code>文件夹。注意：<code>distDir</code> 不能离开你的项目目录，举个例子，<code>../build</code>就是一个无效目录。</p>
<h2>6. env</h2>
<p>Next.js 9.4 后使用新的方式添加环境变量，新的方式更加直观方便、功能强大，具体内容参考<a href="https://juejin.cn/book/7307859898316881957/section/7309078454316564507">《
配置篇 | 环境变量、路径别名与 src 目录》</a>。</p>
<p>添加一个环境变量到 JavaScript bundle 中，举个例子：</p>
<pre><code class="language-javascript">module.exports = {
  env: {
    customKey: &#39;my-value&#39;,
  },
}
</code></pre>
<p>现在你可以在代码中通过 <code>process.env.customKey</code> 获取：</p>
<pre><code class="language-javascript">function Page() {
  return &lt;h1&gt;The value of customKey is: {process.env.customKey}&lt;/h1&gt;
}
 
export default Page
</code></pre>
<p>Next.js 会在构建的时候，将 <code>process.env.customKey</code>替换为 <code>my-value</code>（因为 webpack <a href="https://webpack.js.org/plugins/define-plugin/">DefinePlugin</a> 的特性，不支持通过解构赋值）。举个例子：</p>
<pre><code class="language-javascript">return &lt;h1&gt;The value of customKey is: {process.env.customKey}&lt;/h1&gt;
</code></pre>
<p>相当于：</p>
<pre><code class="language-javascript">return &lt;h1&gt;The value of customKey is: {&#39;my-value&#39;}&lt;/h1&gt;
</code></pre>
<p>最终的结果是：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21b4438a2a8d40ba8726edc48ea45635~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1514&h=288&s=41470&e=png&b=ffffff" alt="image.png"></p>
<h2>7. eslint</h2>
<p>如果项目中检测到 ESLint，Next.js 会在出现错误的时候，让生产构建（<code>next build</code>）失败。</p>
<p>如果你希望即使有错误，也要构建生产代码，可以禁止内置的 ESLint：</p>
<pre><code class="language-javascript">module.exports = {
  eslint: {
    ignoreDuringBuilds: true,
  },
}
</code></pre>
<h2>8. generateBuildId</h2>
<p>Next.js 会在 <code>next build</code> 的时候生成一个 ID，用于标示应用正在使用的版本。应该使用相同的构建并启动多个容器（Docker）。</p>
<p>如果你要为环境的每个阶段进行重建，你需要在不同的容器间生成一致的构建 ID（比如测试、开发、预生产、生产等不同的阶段对应不同的容器，但最好使用相同的构建 ID），使用 <code>next.config.js</code> 的 <code>generateBuildId</code>：</p>
<pre><code class="language-javascript">module.exports = {
  generateBuildId: async () =&gt; {
    // This could be anything, using the latest git hash
    return process.env.GIT_HASH
  },
}
</code></pre>
<h2>9. generateEtags</h2>
<p>Next.js 默认会为每个页面生成 <a href="https://en.wikipedia.org/wiki/HTTP_ETag">etags</a>，如果你希望禁用 HTML 页面生成 etags，使用 <code>next.config.js</code> 的 <code>generateEtags</code>：</p>
<pre><code class="language-javascript">module.exports = {
  generateEtags: false
}
</code></pre>
<h2>10. httpAgentOptions</h2>
<p>在 Nodejs 18 之前，Next.js 会自动使用 <a href="https://github.com/nodejs/undici">undici</a> 作为 <code>fetch()</code> 的 polyfill，并且默认开启 HTTP <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive">Keep-Alive</a>。</p>
<p>如果禁用服务端所有 fetch() 请求的 HTTP Keep-Alive ，使用 <code>next.config.js</code> 的 <code>httpAgentOptions</code> 配置：</p>
<pre><code class="language-javascript">module.exports = {
  httpAgentOptions: {
    keepAlive: false,
  },
}
</code></pre>
<h2>11. images</h2>
<p>如果你想要使用云提供商优化图片而不使用 Next.js 内置的图像优化 API，那可以在 <code>next.config.js</code> 中进行如下配置：</p>
<pre><code class="language-javascript">module.exports = {
  images: {
    loader: &#39;custom&#39;,
    loaderFile: &#39;./my/image/loader.js&#39;,
  },
}
</code></pre>
<p><code>loaderFile</code> 必须指向一个相对于应用根目录的地址，这个文件必须导出一个返回字符串的默认函数，例如：</p>
<pre><code class="language-javascript">export default function myImageLoader({ src, width, quality }) {
  return `https://example.com/${src}?w=${width}&amp;q=${quality || 75}`
}
</code></pre>
<p>就比如你想要使用 Cloudflare，参考 Cloudflare 的 <a href="https://developers.cloudflare.com/images/url-format">url-format</a> 文档：</p>
<pre><code class="language-javascript">// Docs: https://developers.cloudflare.com/images/url-format
export default function cloudflareLoader({ src, width, quality }) {
  const params = [`width=${width}`, `quality=${quality || 75}`, &#39;format=auto&#39;]
  return `https://example.com/cdn-cgi/image/${params.join(&#39;,&#39;)}/${src}`
}
</code></pre>
<p>此为全局修改，如果你只想更改部分图片，那你可以使用 <code>loader</code> prop：</p>
<pre><code class="language-javascript">&#39;use client&#39;
 
import Image from &#39;next/image&#39;
 
const imageLoader = ({ src, width, quality }) =&gt; {
  return `https://example.com/${src}?w=${width}&amp;q=${quality || 75}`
}
 
export default function Page() {
  return (
    &lt;Image
      loader={imageLoader}
      src=&quot;me.png&quot;
      alt=&quot;Picture of the author&quot;
      width={500}
      height={500}
    /&gt;
  )
}
</code></pre>
<h2>12. incrementalCacheHandlerPath</h2>
<p>用于自定义 Next.js 的缓存处理程序，举个例子：</p>
<pre><code class="language-javascript">module.exports = {
  experimental: {
    incrementalCacheHandlerPath: require.resolve(&#39;./cache-handler.js&#39;),
  },
}
</code></pre>
<p>自定义的缓存示例代码为：</p>
<pre><code class="language-javascript">// cache-handler.js
const cache = new Map()
 
module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
    this.cache = {}
  }
 
  async get(key) {
    return cache.get(key)
  }
 
  async set(key, data) {
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
    })
  }
}
</code></pre>
<p>完整的 API 参考 <a href="https://nextjs.org/docs/app/api-reference/next-config-js/incrementalCacheHandlerPath">https://nextjs.org/docs/app/api-reference/next-config-js/incrementalCacheHandlerPath</a></p>
<h2>13. logging</h2>
<p>当在开发模式运行 Next.js ，你可以配置日志等级以及控制台是否记录完整 URL。目前，logging 只应用于使用 fetch API 的数据获取，还不能用于 Next.js 其他日志。</p>
<pre><code class="language-javascript">module.exports = {
  logging: {
    fetches: {
      fullUrl: true,
    },
  },
}
</code></pre>
<h2>14. mdxRs</h2>
<p>使用新的 Rust 编译器编译 MDX 文件，和 <code>@next/mdx</code> 一起使用：</p>
<pre><code class="language-javascript">const withMDX = require(&#39;@next/mdx&#39;)()
 
/** @type {import(&#39;next&#39;).NextConfig} */
const nextConfig = {
  pageExtensions: [&#39;ts&#39;, &#39;tsx&#39;, &#39;mdx&#39;],
  experimental: {
    mdxRs: true,
  },
}
 
module.exports = withMDX(nextConfig)
</code></pre>
<h2>15. onDemandEntries</h2>
<p>onDemandEntries 用于控制开发模式下服务端如何处理内存中构建的页面：</p>
<pre><code class="language-javascript">module.exports = {
  onDemandEntries: {
    // period (in ms) where the server will keep pages in the buffer
    maxInactiveAge: 25 * 1000,
    // number of pages that should be kept simultaneously without being disposed
    pagesBufferLength: 2,
  },
}
</code></pre>
<h2>16. optimizePackageImports</h2>
<p>有些包可以导出成百上千个模块，这会导致开发和生产中的性能问题。</p>
<p>添加一个包到 <code>experimental.optimizePackageImports</code> 后，Next.js 只会加载实际用到的模块：</p>
<pre><code class="language-javascript">module.exports = {
  experimental: {
    optimizePackageImports: [&#39;package-name&#39;],
  },
}
</code></pre>
<p><code>@mui/icons-material</code>, <code>@mui/material</code>, <code>date-fns</code>, <code>lodash</code>, <code>lodash-es</code>, <code>react-bootstrap</code>, <code>@headlessui/react</code>, <code>@heroicons/react</code>以及 <code>lucide-react</code> ，这些库默认已经优化。</p>
<h2>17. output</h2>
<p>在构建的时候，Next.js 会自动追踪每个页面和它的依赖项，以确定部署一个生产版本所需要的所有文件。</p>
<p>这个功能会帮你大幅减少部署的大小。之前使用 Docker 部署的时候，你需要安装 <code>dependencies</code> 中的所有文件才能运行 <code>run start</code>。从 Next.js 12 起，你可以追踪 <code>.next/</code> 目录中的输出文件以实现只包含必要的文件。</p>
<p>之所以能够实现，是因为在 <code>next build</code> 的时候，Next.js 会使用 <code>@vercel/nft</code> 静态分析 <code>import</code>、<code>require</code> 和<code> fs</code> 使用情况来确定页面加载的所有文件。</p>
<p>Next.js 的生产服务器也会在 <code>.next/next-server.js.nft.json</code>中追踪所有它所需要的文件和输出。这个文件就可以被用来在每次追踪的时候，读取文件列表，然后将文件拷贝到部署位置上。</p>
<p>现在让我们在 <code>next.config.js</code> 中开启：</p>
<pre><code class="language-javascript">module.exports = {
  output: &#39;standalone&#39;,
}
</code></pre>
<p>Next.js 会自动在 <code>.next</code>中创建一个 <code>standalone</code> 文件夹，然后拷贝 <code>node_modules</code> 中生产部署会用到的所有必需文件。靠着这个文件夹，都不需要再次安装 <code>node_modules</code> 即可实现部署。</p>
<h2>18. pageExtension</h2>
<p>默认情况下，Next.js 接受 <code>.tsx</code>、<code>.ts</code>、<code>.js</code>、<code>.jsx</code>作为拓展名的文件。 pageExtension 用于接受其他的扩展名比如 markdown （<code>.md</code>、<code>.mdx</code>）</p>
<pre><code class="language-javascript">const withMDX = require(&#39;@next/mdx&#39;)()
 
/** @type {import(&#39;next&#39;).NextConfig} */
const nextConfig = {
  pageExtensions: [&#39;ts&#39;, &#39;tsx&#39;, &#39;mdx&#39;],
  experimental: {
    mdxRs: true,
  },
}
 
module.exports = withMDX(nextConfig)
</code></pre>
<h2>19. 局部渲染</h2>
<p>局部渲染是一个实验性的功能，目前在 <code>next@canary</code> 中可用：</p>
<pre><code class="language-bash">npm install next@canary
</code></pre>
<p>开启局部渲染：</p>
<pre><code class="language-javascript">/** @type {import(&#39;next&#39;).NextConfig} */
const nextConfig = {
  experimental: {
    ppr: true,
  },
}
 
module.exports = nextConfig
</code></pre>
<p>注意：局部渲染目前不能用于客户端导航。</p>
<h2>20. poweredByHeader</h2>
<p>默认情况下，Next.js 会添加 <code>x-powered-by</code>标头，如果要禁用此功能：</p>
<pre><code class="language-javascript">module.exports = {
  poweredByHeader: false,
}
</code></pre>
<h2>21. productionBrowserSourceMaps</h2>
<p>SourceMap 默认在开发环境中开启，在生产构建的时候会禁用以防止源码泄漏，但如果你非要开启：</p>
<pre><code class="language-javascript">module.exports = {
  productionBrowserSourceMaps: true,
}
</code></pre>
<h2>22. reactStrictMode</h2>
<p>从 Next.js 13.4 起，严格模式在 App Router 下默认为 <code>true</code>，所以这个配置仅用于 Pages Router。不过你依然可以设置 <code>reactStrictMode: false</code> 来禁用严格模式。</p>
<p>React 的严格模式是一个为了突出应用中潜在问题的功能，在开发模式中使用会有助于识别不安全的生命周期、过期的 API 用法以及其他功能。使用严格模式，在 <code>next.config.js</code> 中配置：</p>
<pre><code class="language-javascript">module.exports = {
  reactStrictMode: true,
}
</code></pre>
<p>如果不希望整个应用都使用严格模式，只针对某些页面使用的话，那可以用 <code>&lt;React.StrictMode&gt;</code>。</p>
<h2>23. serverComponentsExternalPackages</h2>
<p>Next.js 会自动打包服务端组件和路由处理程序中的依赖项。如果某一个依赖项使用了 Nodejs 特定的功能，那你可以选择从 Bundle 中去除该依赖项，然后使用原生的 Nodejs <code>require</code>。</p>
<pre><code class="language-javascript">/** @type {import(&#39;next&#39;).NextConfig} */
const nextConfig = {
  experimental: {
    serverComponentsExternalPackages: [&#39;@acme/ui&#39;],
  },
}
 
module.exports = nextConfig
</code></pre>
<h2>24. trailingSlash</h2>
<p>默认情况下，Next.js 会将带尾部斜杠的 URL 重定向到没有尾部斜杠的地址.举个例子，<code>/about/</code>会重定向到 <code>/about</code>。你也可以进行相反的配置，将没有尾部斜杠的地址重定向到带尾部斜杠的地址：</p>
<pre><code class="language-javascript">module.exports = {
  trailingSlash: true,
}
</code></pre>
<p>现在，<code>/about</code>重定到 <code>/about/</code>。</p>
<h2>25. transpilePackages</h2>
<p>Next.js 可以自动编译和打包来自本地的包（如 monorepos）或者外部依赖（node_modules）。以前是通过使用 <a href="https://www.npmjs.com/package/next-transpile-modules">next-transpile-modules</a> 这个包，有了这个选项就可以直接使用了：</p>
<pre><code class="language-javascript">/** @type {import(&#39;next&#39;).NextConfig} */
const nextConfig = {
  transpilePackages: [&#39;@acme/ui&#39;, &#39;lodash-es&#39;],
}
 
module.exports = nextConfig
</code></pre>
<h2>26. turbo</h2>
<p>这些功能是实验性的，只有当使用 <code>next --turbo</code> 的时候才会开启。</p>
<p>目前，Turbopack 支持 webpack loader API 的子集，允许你在 Turbopack 中使用一些 webpack loader 转换代码。举个例子：</p>
<pre><code class="language-javascript">module.exports = {
  experimental: {
    turbo: {
      rules: {
        // Option format
        &#39;*.md&#39;: [
          {
            loader: &#39;@mdx-js/loader&#39;,
            options: {
              format: &#39;md&#39;,
            },
          },
        ],
        // Option-less format
        &#39;*.mdx&#39;: [&#39;@mdx-js/loader&#39;],
      },
    },
  },
}
</code></pre>
<p>现在，你可以在应用中使用：</p>
<pre><code class="language-javascript">import MyDoc from &#39;./my-doc.mdx&#39;
 
export default function Home() {
  return &lt;MyDoc /&gt;
}
</code></pre>
<p>类似于 webpack 的 resolve.alias，Turbopack 也可以配置别名：</p>
<pre><code class="language-javascript">module.exports = {
  experimental: {
    turbo: {
      resolveAlias: {
        underscore: &#39;lodash&#39;,
        mocha: { browser: &#39;mocha/browser-entry.js&#39; },
      },
    },
  },
}
</code></pre>
<p>在这个例子中，使用 <code>import underscore from &#39;underscore&#39;</code>其实会导入 lodash。</p>
<p>Turbopack 也支持条件别名，目前只支持 browser 这个条件。在这个例子中，当 Turbopack 以浏览器环境为目标的时候，导入 mocha 模块相当于导入 mocha/browser-entry.js。</p>
<h2>27. typedRouters</h2>
<p>对静态类型链接的实验性支持，此功能需要在 App Router 下以及开启使用 TypeScript：</p>
<pre><code class="language-javascript">/** @type {import(&#39;next&#39;).NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
}
 
module.exports = nextConfig
</code></pre>
<h2>28. typescript</h2>
<p>如果出现 TypeScript 错误，生产构建（<code>next build</code>）会失败。如果你希望即便有错误，也要构建生产代码：</p>
<pre><code class="language-javascript">module.exports = {
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}
</code></pre>
<h2>29. urlImports</h2>
<p>URL 导入是一项实验性功能，允许你从外部服务器导入模块。</p>
<p>如果你要使用该功能，使用示例如下：</p>
<pre><code class="language-javascript">module.exports = {
  experimental: {
    urlImports: [&#39;https://example.com/assets/&#39;, &#39;https://cdn.skypack.dev&#39;],
  },
}
</code></pre>
<p>在这个例子中，添加了允许的资源前缀（毕竟要保证安全）。</p>
<p>然后你就可以直接通过 URL 导入模块：</p>
<pre><code class="language-javascript">import { a, b, c } from &#39;https://example.com/assets/some/module.js&#39;
</code></pre>
<p>当使用 URL 导入的时候，Next.js 会创建一个 <code>next.lock</code>目录包含一个 lockfile 和获取的资源。这个目录必须要提交到 Git，不能通过 <code>.gitignore</code>忽略。</p>
<p>当运行 <code>next dev</code>的时候，Next.js 会下载并添加所有新发现的导入 URL 到 lockfile 中。当运行 <code>next build</code>的时候，Next.js 会只使用 lockfile 构建用于生产版本的应用。</p>
<p>使用 URL 导入的一些例子：</p>
<p>使用 skypack：</p>
<pre><code class="language-javascript">import confetti from &#39;https://cdn.skypack.dev/canvas-confetti&#39;
import { useEffect } from &#39;react&#39;
 
export default () =&gt; {
  useEffect(() =&gt; {
    confetti()
  })
  return &lt;p&gt;Hello&lt;/p&gt;
}
</code></pre>
<p>静态图片导入：</p>
<pre><code class="language-javascript">import Image from &#39;next/image&#39;
import logo from &#39;https://example.com/assets/logo.png&#39;
 
export default () =&gt; (
  &lt;div&gt;
    &lt;Image src={logo} placeholder=&quot;blur&quot; /&gt;
  &lt;/div&gt;
)
</code></pre>
<p>CSS 中的 URLs：</p>
<pre><code class="language-javascript">.className {
  background: url(&#39;https://example.com/assets/hero.jpg&#39;);
}
</code></pre>
<p>导入资源：</p>
<pre><code class="language-javascript">const logo = new URL(&#39;https://example.com/assets/file.txt&#39;, import.meta.url)
 
console.log(logo.pathname)
 
// prints &quot;/_next/static/media/file.a9727b5d.txt&quot;
</code></pre>
<h2>30. 自定义 Webpack 配置</h2>
<p>为了扩展 webpack 的用法，你需要在 next.config.js 中定义一个函数用于扩展它的配置，举个例子：</p>
<pre><code class="language-javascript">module.exports = {
  webpack: (
    config,
    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }
  ) =&gt; {
    // Important: return the modified config
    return config
  },
}
</code></pre>
<p>webpack 函数会被执行两次，一次在服务端，一次在客户端，你可以使用 isServer 属性来区分是客户端配置还是服务端配置。</p>
<p>webpack 函数的第二个参数是一个具有以下属性的对象：</p>
<ul>
<li><code>buildId</code>：<code>String</code>，构建 ID，构建的唯一标识</li>
<li><code>dev</code>：<code>Boolean</code> 编译是否会在开发中完成</li>
<li><code>isServer</code>：<code>Boolean</code>，如果 true 表示服务端编译，如果 false 表示客户端编译</li>
<li><code>nextRuntime</code>：<code>String | undefined</code>，服务端编译的目标运行时，要么是 <code>&quot;edge&quot;</code> ，要么是 <code>&quot;nodejs&quot;</code>，<code>undefined</code>用于客户端编译</li>
<li><code>defaultLoaders</code>：<code>Object</code> Next.js 内部使用的默认加载器<ul>
<li><code>babel</code>：<code>Object</code> 默认的 <code>babel-loader</code> 配置</li>
</ul>
</li>
</ul>
<p><code>defaultLoaders.babel</code> 示例用法：</p>
<pre><code class="language-javascript">// 这段来自于 @next/mdx 插件源码:
// https://github.com/vercel/next.js/tree/canary/packages/next-mdx
module.exports = {
  webpack: (config, options) =&gt; {
    config.module.rules.push({
      test: /\.mdx/,
      use: [
        options.defaultLoaders.babel,
        {
          loader: &#39;@mdx-js/loader&#39;,
          options: pluginOptions.options,
        },
      ],
    })
 
    return config
  },
}
</code></pre>
<h2>31. webVitalsAttribution</h2>
<p>在调试 Web Vitals 相关的问题时，如果能查明根源通常会很有帮助。比如在 CLS 中，我们可能想知道最大的布局偏移发生时偏移的第一个元素，或者 LCP 中，我们可能想要知道 LCP 对应的元素。如果该元素是图片，知道它的 URL 有助于我们进行优化。</p>
<p>这就需要用到 webVitalsAttribution 配置项，它会帮助我们获取更深层的信息如 <a href="https://developer.mozilla.org/docs/Web/API/PerformanceEventTiming">PerformanceEventTiming</a>、<a href="https://developer.mozilla.org/docs/Web/API/PerformanceNavigationTiming">PerformanceNavigationTiming</a>、<a href="https://developer.mozilla.org/docs/Web/API/PerformanceResourceTiming">PerformanceResourceTiming</a>。</p>
<pre><code class="language-javascript">experimental: {
  webVitalsAttribution: [&#39;CLS&#39;, &#39;LCP&#39;]
}
</code></pre>
<p>有效的归因值都是 web-vitals 中的特定指标，在 <a href="https://github.com/vercel/next.js/blob/442378d21dd56d6e769863eb8c2cb521a463a2e0/packages/next/shared/lib/utils.ts#L43">NextWebVitalsMetric</a> 中可以查看：</p>
<pre><code class="language-javascript">export type NextWebVitalsMetric = {
  id: string
  startTime: number
  value: number
} &amp; (
  | {
      label: &#39;web-vital&#39;
      name: &#39;FCP&#39; | &#39;LCP&#39; | &#39;CLS&#39; | &#39;FID&#39; | &#39;TTFB&#39; | &#39;INP&#39;
    }
  | {
      label: &#39;custom&#39;
      name:
        | &#39;Next.js-hydration&#39;
        | &#39;Next.js-route-change-to-render&#39;
        | &#39;Next.js-render&#39;
    }
)
</code></pre>
<h2>参考链接</h2>
<ol>
<li><a href="https://nextjs.org/docs/app/api-reference/next-config-js">https://nextjs.org/docs/app/api-reference/next-config-js</a></li>
</ol>

</body>
</html>
  